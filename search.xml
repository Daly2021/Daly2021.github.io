<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库学习笔记</title>
      <link href="posts/769d2f87.html"/>
      <url>posts/769d2f87.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL数据库学习-1"><a href="#MySQL数据库学习-1" class="headerlink" title="MySQL数据库学习|1"></a>MySQL数据库学习|1</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><blockquote><p>概念：数据库用来<strong>存放数据</strong>的</p><p>例如：班上需要存同学的信息，一般用Excel表格存。</p><p>用<strong>行</strong>和<strong>列</strong>的方式来，表格的形式，这也是关系型数据库存储的形式。</p></blockquote><p>后台（后端）的编程语言主要就是用来<strong>运算</strong>和<strong>存储</strong>的。</p><p>很多人选择学习前端，我认为前端是用来<strong>采集</strong>和<strong>展示</strong>数据的，但有要求，必须漂亮，交互友好，不然谁愿意放数据？</p><p>例如我采集到了你的信息，存在哪里？<strong>内存</strong>？不可以，一断电就没了，所以存在磁盘上，这个过程叫<strong>持久化</strong>。</p><p>存储注意问题：</p><ul><li>性能问题</li><li>所以mysql关系型数据库出来了，什么是关系型数据库？我的理解就是<strong>表与表之间是有关系</strong>的。所以：<ul><li>MySQL是一种开放源代码的<strong>关系型</strong>数据库管理系统（RDBMS），使用最常用的数据库管理语言–<strong>结构化查询语言</strong>（SQL全称就是结构化查询语言）进行数据库管理。</li><li>MySQL是开放源代码的，因此任何人都可以在General Public License的许可下下载并根据个性化的需要对其进行修改。</li><li>MySQL因为其速度、可靠性和适应性而备受关注。MySQL是管理内容最好的选择。</li></ul></li></ul><blockquote><p>常见的关系型数据库有哪些呢？MySQL（orale甲骨文公司）  SQL server  （微软公司） db2（IBM公司的） Orale   —       mysql优势 :免费开源</p></blockquote><h2 id="1-1在Windows安装8-0的版本-Mysql"><a href="#1-1在Windows安装8-0的版本-Mysql" class="headerlink" title="1.1在Windows安装8.0的版本 Mysql"></a>1.1在Windows安装8.0的版本 Mysql</h2><h3 id="卸载5-7版本"><a href="#卸载5-7版本" class="headerlink" title="卸载5.7版本"></a>卸载5.7版本</h3><blockquote><p>我的win10电脑之前使用的是mysql5.7版本的  使用的是sqlyog图形化工具，所以要先卸载mysql5.7，尝试使用8.0版本的数据库，换成使用Navicat和DataGrip工具，这些是收费的工具，有破解和别人下载好的，我自己的操作步骤都会截图一步一步的学习的。好好折腾</p></blockquote><p>MySQL5.7升级到8.0，mysql和常用的软件不同，并没有点击一下更新就可以直接从5.7更新到8.0这种操作。。。。</p><p>我的操作步骤：</p><ol><li><p>停止MySQL服务</p></li><li><p>卸载MySQL相关的程序 在设置win+i打开</p><p><img src="https://codecheng-1305009997.cos.ap-chengdu.myqcloud.com/img/20210420172944.png"></p></li></ol><p>这两个都需要，如果你安装了全部就需要卸载这些，我只安装了服务端</p><p><img src="https://blog.noheart.cn/upload/mysql/002.jpg"></p><ol start="3"><li><p>安装目录在C盘，首先打开C:\Program Files，删除MySQL文件夹</p><p><img src="https://blog.noheart.cn/upload/mysql/003.jpg"></p><blockquote><p> 打开隐藏文件ProgramData文件夹，删除下面的MySQL文件</p></blockquote><p><img src="https://blog.noheart.cn/upload/mysql/004.jpg"></p><ol start="4"><li><p>卸载MySQL相关注册表，这里也是很多r人重装不成功的坑。</p><blockquote><p>Windows+R–&gt;regedit–&gt;打开注册表</p></blockquote><p><img src="https://blog.noheart.cn/upload/mysql/005.jpg"></p><blockquote><p>根据路径打开并删除：</p></blockquote><p>HKEY_LOCAL_MACHINE/SYSTEM/ControlSet001/Services/Eventlog/Applications/MySQL </p><p>HKEY_LOCAL_MACHINE/SYSTEM/ControlSet002/Services/Eventlog/Applications/MySQL<br> HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/Eventlog/Applications/MySQL</p><p>HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services一般服务会以相同的名字(名字通常是MySQL</p><blockquote><p>还有就是F3或Ctrl+F打开查找框，输入MySQL，注意焦点放在计算机上</p><p>还有重要的一步删除Connector Net XXX注册表，大家失败的原因好多也是在这个注册表上面</p></blockquote><p><img src="https://blog.noheart.cn/upload/mysql/006.jpg"></p><p><img src="https://blog.noheart.cn/upload/mysql/007.jpg"></p><p>完成以上四步就已经卸载干净MySQL了，可以安装8.0了</p><h3 id="安装8-0版本"><a href="#安装8-0版本" class="headerlink" title="安装8.0版本"></a>安装8.0版本</h3><blockquote><p> 去官网下载:最新版的传送门:<a href="https://dev.mysql.com/downloads/mysql/">点击此处跳转官网下载</a></p></blockquote><p>下载好后详细步骤图解</p><p>基本上都是next</p><p><img src="https://codecheng-1305009997.cos.ap-chengdu.myqcloud.com/img/20210420184653.png"></p><p><img src="https://codecheng-1305009997.cos.ap-chengdu.myqcloud.com/img/20210420185012.png"></p><p><img src="https://codecheng-1305009997.cos.ap-chengdu.myqcloud.com/img/20210420185310.png"></p><p><img src="https://codecheng-1305009997.cos.ap-chengdu.myqcloud.com/img/20210420185539.png"></p><p><img src="https://codecheng-1305009997.cos.ap-chengdu.myqcloud.com/img/20210420185636.png"></p><p><img src="https://codecheng-1305009997.cos.ap-chengdu.myqcloud.com/img/20210420185830.png"></p><p><img src="https://codecheng-1305009997.cos.ap-chengdu.myqcloud.com/img/20210420185927.png"></p><p><img src="https://codecheng-1305009997.cos.ap-chengdu.myqcloud.com/img/20210420190031.png"></p><p><img src="https://codecheng-1305009997.cos.ap-chengdu.myqcloud.com/img/20210420190250.png"></p><p>傻瓜式安装就可以了 下一步</p></li></ol></li></ol><h2 id="2-SQL语句分类"><a href="#2-SQL语句分类" class="headerlink" title="2.SQL语句分类"></a>2.SQL语句分类</h2><ul><li>1.DDL(Data Definition Language):数据定义语言，用来定义数据库对象：库、表、列等。功能：创建、删除、修改库和表结构。</li><li>2.DML(Data Manipulation Language):数据操作语言，用来定义数据库记录:增、删、改表记录。</li><li>3.DCL(Data Control Language):数据控制语言，用来定义访问权限和安全级别。</li><li><strong>4.DQL(Data Query Language):数据查询语言，用来查询记录。</strong>这个才是<strong>重中之重</strong>，先整理前三个</li></ul><h2 id="3-socket-介绍"><a href="#3-socket-介绍" class="headerlink" title="3.socket 介绍"></a>3.socket 介绍</h2><ul><li>客户端和服务端是使用socket链接的。</li><li>socket中文翻译是插座，但是学术叫套接字。其实就是计算机和计算机链接的方式。</li><li>一个计算机使用ip+端口使用某种协议就能和另外一台机子的ip+端口链接通信。（TCP/UDP）</li><li>mysql使用的默认端口是3306，一个客户端随便使用一个端口，就能连接上服务。</li><li>服务器的ip+端口是固定的,客户端往往是随机的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
          <category> 巩固 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL8.0 </tag>
            
            <tag> 零基础整理 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用下载整理</title>
      <link href="posts/fc46bbd0.html"/>
      <url>posts/fc46bbd0.html</url>
      
        <content type="html"><![CDATA[<h2 id="国内编程网站网址"><a href="#国内编程网站网址" class="headerlink" title="国内编程网站网址"></a>国内编程网站网址</h2><p><a href="https://www.nhooo.com/">https://www.nhooo.com/</a></p><p><a href="https://www.w3cschool.cn/">https://www.w3cschool.cn/</a></p><p><a href="https://www.w3school.com.cn/index.html">https://www.w3school.com.cn/index.html</a></p><p><a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p><p><a href="https://www.runoob.com/">https://www.runoob.com/</a></p><p><a href="https://huke88.com/">https://huke88.com/</a></p><p><a href="https://www.iteye.com/">https://www.iteye.com/</a></p><p><a href="http://yun.itheima.com/course/index/p/3.html?yzw">http://yun.itheima.com/course/index/p/3.html?yzw</a></p><p><a href="https://www.csdn.net/?spm=1001.2101.3001.4476">https://www.csdn.net/?spm=1001.2101.3001.4476</a></p><p><a href="http://c.biancheng.net/">http://c.biancheng.net/</a></p><p><a href="https://www.csdn.net/?spm=1000.2115.3001.4476">https://www.csdn.net/?spm=1000.2115.3001.4476</a></p><p><a href="https://www.cnblogs.com/">https://www.cnblogs.com/</a></p><p><a href="https://www.jb51.net/">https://www.jb51.net/</a></p><h2 id="国外编程网站网址"><a href="#国外编程网站网址" class="headerlink" title="国外编程网站网址"></a>国外编程网站网址</h2><p><a href="https://www.bitdegree.org/learn/">https://www.bitdegree.org/learn/</a></p><p><a href="https://www.coursera.org/">https://www.coursera.org/</a>?</p><p><a href="https://www.codecademy.com/">https://www.codecademy.com</a></p><p><a href="https://www.edx.org/course/subject/computer-science">https://www.edx.org/course/subject/computer-science</a></p><p><a href="https://www.khanacademy.org/computing/computer-programming">https://www.khanacademy.org/computing/computer-programming</a></p><p><a href="https://www.codewars.com/">https://www.codewars.com</a></p><p><a href="https://code.org/">https://code.org</a></p><p><a href="https://www.udemy.com/courses/development/web-development/">https://www.udemy.com/courses/development/web-development/</a></p><p><a href="https://dash.generalassemb.ly/">https://dash.generalassemb.ly</a></p><p><a href="https://www.freecodecamp.org/">https://www.freecodecamp.org</a></p><p><a href="https://www.codeconquest.com/">https://www.codeconquest.com</a></p><p><a href="https://ocw.mit.edu/index.htm">https://ocw.mit.edu/index.htm</a></p><p><a href="https://www.theodinproject.com/">https://www.theodinproject.com</a></p><p><a href="https://www.w3schools.com/">https://www.w3schools.com</a></p><p><a href="https://hackr.io/">https://hackr.io</a></p><p><a href="https://bento.io/">https://bento.io</a></p><p><a href="https://www.codeavengers.com/">https://www.codeavengers.com</a></p><p><a href="https://www.sololearn.com/">https://www.sololearn.com</a></p><p><a href="https://developers.google.com/learn">https://developers.google.com/learn</a></p><p><a href="https://upskillcourses.com/">https://upskillcourses.com</a></p><p><a href="https://www.pluralsight.com/">https://www.pluralsight.com</a></p><p><a href="https://codeasy.net/">https://codeasy.net</a></p><p>blog.agupieware.com/2014/05/online-learning-bachelors-level.html</p><p><a href="https://edabit.com/">https://edabit.com</a></p><hr><h2 id="常用下载链接"><a href="#常用下载链接" class="headerlink" title="常用下载链接"></a>常用下载链接</h2><ol><li><p>JDK下载地址：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133</a> 151.html</p></li><li><p>安装IDEA（全家桶网站）官方网站：<a href="https://www.jetbrains.com/">https://www.jetbrains.com/</a></p></li><li><p>课外扩展：<strong>各种字符集和编码详解</strong> <a href="https://www.cnblogs.com/happyday56/p/4135845.html">https://www.cnblogs.com/happyday56/p/4135845.html</a></p></li><li><p>【编码规范：推荐参考阿里巴巴开发手册编程规范】 下载地址：阿里巴巴开发手册<a href="https://files-cdn.cnblogs.com/files/han-1034683568/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E7%BB%88%E6%9E%81%E7%89%88v1.3.0.pdf">https://files-cdn.cnblogs.com/files/han-1034683568/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E7%BB%88%E6%9E%81%E7%89%88v1.3.0.pdf</a></p></li><li><p>课外扩展<strong>稀疏数组</strong> <a href="https://blog.csdn.net/baolingye/article/details/99943083">https://blog.csdn.net/baolingye/article/details/99943083</a></p></li><li><p>mysql官网 : <a href="https://www.mysql.com/">https://www.mysql.com/</a></p></li><li><p>mysql5.7 64位下载地址: <a href="https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.19-winx64.zip">https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.19-winx64.zip</a> 电脑是64位的就下载使用64位版本的！</p></li><li><p>W3C World Wide Web Consortium（万维网联盟）  <a href="http://www.w3.org/Web%E6%8A%80%E6%9C%AF%E9%A2%86%E5%9F%9F%E6%9C%80%E6%9D%83%E5%A8%81%E5%92%8C%E5%85%B7%E5%BD%B1%E5%93%8D%E5%8A%9B%E7%9A%84%E5%9B%BD%E9%99%85%E4%B8%AD%E7%AB%8B%E6%80%A7%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E6%9C%BA%E6%9E%84">http://www.w3.org/Web技术领域最权威和具影响力的国际中立性技术标准机构</a>  <a href="http://www.chinaw3c.org/">http://www.chinaw3c.org/</a></p></li><li><p>CSS渐变样式 网站推荐：<a href="http://color.oulu.me/">http://color.oulu.me/</a></p></li><li><p>JavaScript 参考网站：<a href="https://www.liaoxuefeng.com/wiki/1022910821149312%E5%BB%96%E9%9B%AA%E5%B3%B0">https://www.liaoxuefeng.com/wiki/1022910821149312廖雪峰</a></p></li><li><p>jQuery官网：<a href="https://jquery.com/">https://jquery.com/</a></p></li><li><p>tomcat官网：<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a></p></li><li><p>安装Maven 官网;<a href="https://maven.apache.org/">https://maven.apache.org/</a></p></li><li><p>Maven仓库的使用 地址：<a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p></li><li><p>Mybatis官方文档 : <a href="http://www.mybatis.org/mybatis-3/zh/index.html">http://www.mybatis.org/mybatis-3/zh/index.html</a>                                                                                             Mybatis GitHub : <a href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a></p></li><li><p>Spring官网 : <a href="http://spring.io/">http://spring.io/</a>                                                                                                                                                                           Spring 官方下载地址 : <a href="https://repo.spring.io/libs-release-local/org/springframework/spring/">https://repo.spring.io/libs-release-local/org/springframework/spring/</a>                                                                Spring GitHub : <a href="https://github.com/spring-projects">https://github.com/spring-projects</a></p></li><li><p>Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。                                                                              查看官方文档：<a href="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web">https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web</a>. html#spring-web</p></li><li><p>iView                                                                                                                                                                                                                 iview 是一个强大的基于 Vue 的 UI 库，有很多实用的基础组件比 elementui 的组件更丰富，主要服务于 PC 界面的中后台产品。使用单文件的 Vue 组件化开发模式 基于 npm + webpack + babel 开发，支持 ES2015 高质量、功能丰富 友好的 API ，自由灵活地使用空间。                                                                                                                                                                                                                     [官网地址] <a href="https://www.iviewui.com/">https://www.iviewui.com/</a>                                                                                                                                                                [Github] <a href="https://github.com/TalkingData/iview-weapp">https://github.com/TalkingData/iview-weapp</a>                                                                                                                                    [iview-admin] <a href="https://github.com/iview/iview-admin">https://github.com/iview/iview-admin</a>                                                                                                                                           备注：属于前端主流框架，选型时可考虑使用，主要特点是移动端支持较多</p></li><li><p>ElementUI                                                                                                                                                                                                                      Element 是饿了么前端开源维护的 Vue UI 组件库，组件齐全，基本涵盖后台所需的所有组件，文档讲 解详细，例子也很丰富。主要用于开发 PC 端的页面，是一个质量比较高的 Vue UI 组件库。                                                                                                                             [官网地址] <a href="http://element-cn.eleme.io/#/zh-CN">http://element-cn.eleme.io/#/zh-CN</a>                                                                                                                                             [Github] <a href="https://github.com/ElementUI/element-starter">https://github.com/ElementUI/element-starter</a>                                                                                                                                           [vue-element-admin] <a href="https://github.com/PanJiaChen/vue-element-admin">https://github.com/PanJiaChen/vue-element-admin</a>                                                                                                             备注：属于前端主流框架，选型时可考虑使用，主要特点是桌面端支持较多</p></li><li><p>ICE                                                                                                                                                                                                                                          飞冰是阿里巴巴团队基于 React/Angular/Vue 的中后台应用解决方案，在阿里巴巴内部，已经有 270 多 个来自几乎所有 BU 的项目在使用。飞冰包含了一条从设计端到开发端的完整链路，帮助用户快速搭建 属于自己的中后台应用。                                                        [官网地址] <a href="https://alibaba.github.io/ice">https://alibaba.github.io/ice</a>                                                                                                                                                             [Github] <a href="https://github.com/alibaba/ice">https://github.com/alibaba/ice</a>                                                                                                                                                                   备注：主要组件还是以 React 为主，截止 2019 年 02 月 17 日更新博客前对 Vue 的支持还不太完善， 目前尚处于观望阶段</p></li><li><p>VantUI                                                                                                                                                                                                                                     Vant UI 是有赞前端团队基于有赞统一的规范实现的 Vue 组件库，提供了一整套 UI 基础组件和业务组 件。通过 Vant，可以快速搭建出风格统一的页面，提升开发效率。                                                                                                                                                                         [官网地址] <a href="https://youzan.github.io/vant/#/zh-CN/intro">https://youzan.github.io/vant/#/zh-CN/intro</a>                                                                                                                             [Github] <a href="https://github.com/youzan/vant">https://github.com/youzan/vant</a></p></li><li><p>AtUI                                                                                                                                                                                                                                           at-ui 是一款基于 Vue 2.x 的前端 UI 组件库，主要用于快速开发 PC 网站产品。 它提供了一套 npm + webpack + babel 前端开发工作流程，CSS 样式独立，即使采用不同的框架实现都能保持统一的 UI 风 格。 的 UI 风格。                                                                                 [官网地址] <a href="https://at-ui.github.io/at-ui/#/zh">https://at-ui.github.io/at-ui/#/zh</a>                                                                                                                                                          [Github] <a href="https://github.com/at-ui/at-ui">https://github.com/at-ui/at-ui</a></p></li><li><p>CubeUI                                                                                                                                                                                                               cube-ui 是滴滴团队开发的基于 Vue.js 实现的精致移动端组件库。支持按需引入和后编译，轻量灵活； 扩展性强，可以方便地基于现有组件实现二次开发。                                                                                                                                                                                               [官网地址] <a href="https://didi.github.io/cube-ui/#/zh-CN">https://didi.github.io/cube-ui/#/zh-CN</a>                                                                                                                                         [Github] <a href="https://github.com/didi/cube-ui/">https://github.com/didi/cube-ui/</a></p></li><li><p>Flutter Flutter 是谷歌的移动端 UI 框架，可在极短的时间内构建 Android 和 iOS 上高质量的原生级应用。 Flutter 可与现有代码一起工作, 它被世界各地的开发者和组织使用, 并且 Flutter 是免费和开源的。                                                                                                                   [官网地址] <a href="https://flutter.dev/docs">https://flutter.dev/docs</a>                                                                                                                                                               [Github] <a href="https://github.com/flutter/flutter">https://github.com/flutter/flutter</a>                                                                                                                                                              备注：Google 出品，主要特点是快速构建原生 APP 应用程序，如做混合应用该框架为必选框架</p></li><li><p>Ionic Ionic 既是一个 CSS 框架也是一个 Javascript UI 库，Ionic 是目前最有潜力的一款 HTML5 手机应用开发 框架。通过 SASS 构建应用程序，它提供了很多 UI 组件来帮助开发者开发强大的应用。它使用 JavaScript MVVM 框架和 AngularJS/Vue 来增强应用。提供数据的双向绑定，使用它成为 Web 和移动 开发者的共同选择。                                                                                                                            [官网地址] <a href="https://ionicframework.com/">https://ionicframework.com/</a>                                                                                                                                                              [官网文档] <a href="https://ionicframework.com/docs/">https://ionicframework.com/docs/</a>                                                                                                                                                           [Github] <a href="https://github.com/ionic-team/ionic">https://github.com/ionic-team/ionic</a></p></li><li><p>mpvue mpvue 是美团开发的一个使用 Vue.js 开发小程序的前端框架，目前支持 微信小程序、百度智能小程 序，头条小程序 和 支付宝小程序。 框架基于 Vue.js，修改了的运行时框架 runtime 和代码编译器 compiler 实现，使其可运行在小程序环境中，从而为小程序开发引入了 Vue.js 开发体验。                                                                                                                                                                                       [官网地址] <a href="http://mpvue.com/">http://mpvue.com/</a>                                                                                                                                                                         [Github] <a href="https://github.com/Meituan-Dianping/mpvue">https://github.com/Meituan-Dianping/mpvue</a>                                                                                                                                         备注：完备的 Vue 开发体验，并且支持多平台的小程序开发，推荐使用</p></li><li><p>WeUI WeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页和微信小程序 量身设计，令用户的使用感知更加统一。包含 button、cell、dialog、toast、article、icon 等各式元 素。                                                                                         [官网地址] <a href="https://weui.io/">https://weui.io/</a>                                                                                                                                                                                    [Github] <a href="https://github.com/weui/weui.git">https://github.com/weui/weui.git</a>                                                                                                                                                                            注：以上知识点已将 WebApp 开发所需技能全部梳理完毕</p></li><li><p>Axios   Axios 是一个开源的可以用在浏览器端和 NodeJS 的异步通信框架，她的主要作用就是实现 AJAX 异 步通信                                                                                                                                                                                                                GitHub：<a href="https://github.com/axios/axios">https://github.com/axios/axios</a>                                                                                                                                                                          中文文档：<a href="http://www.axios-js.com/">http://www.axios-js.com/</a></p></li><li><p>Vue的生命周期 官方文档：<a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">https://cn.vuejs.org/v2/guide/instance.html#生命周期图示</a></p></li><li><p>Element-ui 是饿了么前端出品的基于 Vue.js的 后台组件库，方便程序员进行页面快速布局和构建                                                              官网： <a href="http://element-cn.eleme.io/#/zh-CN">http://element-cn.eleme.io/#/zh-CN</a></p></li><li><p>vue-element-admin                       概述 vue-element-admin是基于element-ui 的一套后台管理系统集成方案。                                                                               功能：<a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/#%E5%8A%9F%E8%83%BD">https://panjiachen.github.io/vue-element-admin-site/zh/guide/#功能</a>                                                                                                  GitHub地址：<a href="https://github.com/PanJiaChen/vue-element-admin">https://github.com/PanJiaChen/vue-element-admin</a>                                                                                                                               项目在线预览：<a href="https://panjiachen.gitee.io/vue-element-admin">https://panjiachen.gitee.io/vue-element-admin</a></p></li><li><p>vue-admin-template     vue-admin-template是基于vue-element-admin的一套后台管理系统基础模板（最少精简版），可作为 模板进行二次开发。                                                                                                                                                                                                    GitHub地址：<a href="https://github.com/PanJiaChen/vue-admin-template">https://github.com/PanJiaChen/vue-admin-template</a>                                                                                                                     建议：你可以在 vue-admin-template 的基础上进行二次开发，把 vue-element-admin 当做工具 箱，想要什么功能或者组件就去 vue-element-admin 那里复制过来</p></li><li><p>打开 [git官网] <a href="https://git-scm.com/%EF%BC%8C%E4%B8%8B%E8%BD%BDgit%E5%AF%B9%E5%BA%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%88%E6%9C%AC%E3%80%82">https://git-scm.com/，下载git对应操作系统的版本。</a>                                                                                                                          官网下载太慢，我们可以使用淘宝镜像下载：<a href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a></p></li><li><p>阿里云购买服务器：<a href="https://www.aliyun.com/minisite/goods?userCode=0phtycgr">https://www.aliyun.com/minisite/goods?userCode=0phtycgr</a></p></li><li><p>、Maven下载安装 下载地址：<a href="http://maven.apache.org/">http://maven.apache.org/</a>                                                                                                                                               小知识点： 作为一个java程序员 apache 网站的规律得知道都是 项目名.apache.org                                                                                                     maven<a href="http://maven.apache.org/">http://maven.apache.org/</a>                                                                                                                                                                                                        tomcat<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a>                                                                                                                                                                                            dubbo<a href="http://dubbo.apache.org/">http://dubbo.apache.org/</a>                                                                                                                                                                                                       hadoop<a href="http://hadoop.apache.org/">http://hadoop.apache.org/</a></p></li><li><p>maven管理依赖也就是jar包牛逼之处是不用我们自己下载，会从一些地方自动下载                                                                                            maven远程仓库: <a href="https://mvnrepository.com/">https://mvnrepository.com/</a>                                                                                                                                                      maven远程仓库: <a href="https://maven.aliyun.com/mvn/search">https://maven.aliyun.com/mvn/search</a></p></li><li><p>、Windows安装 redis下载安装包：<a href="https://github.com/dmajkic/redis/releases">https://github.com/dmajkic/redis/releases</a> </p></li><li><p>安装vmware 直接腾讯软件中心下载 <a href="https://pc.qq.com/search.html#!keyword=vmware">https://pc.qq.com/search.html#!keyword=vmware</a></p></li><li><p>我是用centos 7      安装linux   <a href="https://developer.aliyun.com/mirror/">https://developer.aliyun.com/mirror/</a></p></li><li><p>远程连接工具   安装finalshell <a href="http://www.hostbuf.com/">http://www.hostbuf.com/</a> 免费  xshell收费</p></li><li><p>宝塔面板<a href="https://www.bt.cn/">https://www.bt.cn/</a></p><h2 id="一些常去的网站资源"><a href="#一些常去的网站资源" class="headerlink" title="一些常去的网站资源"></a>一些常去的网站资源</h2><h3 id="照片"><a href="#照片" class="headerlink" title="照片"></a>照片</h3><p>pixabay: <a href="https://pixabay.com/zh/">https://pixabay.com/zh/</a><br>Unsplash:<a href="https://unsplash.com/">https://unsplash.com/</a><br>Pexels:<a href="https://www.pexels.com/zh-cn/">https://www.pexels.com/zh-cn/</a><br>Foodiesfeed:<a href="https://www.foodiesfeed.com/">https://www.foodiesfeed.com</a><br>cc零图片网<a href="https://cc0.cn/">https://cc0.cn/</a><br>logo神器：<a href="https://www.logosc.cn/so/">https://www.logosc.cn/so/</a></p><h3 id="2-字体："><a href="#2-字体：" class="headerlink" title="2. 字体："></a>2. 字体：</h3><p>字由：<a href="https://www.logosc.cn/so/">https://www.logosc.cn/so/</a><br>100font:<a href="https://www.100font.com/">https://www.100font.com/</a><br>iconfont:<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p><h3 id="3-视频："><a href="#3-视频：" class="headerlink" title="3.视频："></a>3.视频：</h3><p>Videezy:<a href="https://www.videezy.com/">https://www.videezy.com/</a><br>Videvo:<a href="https://www.videvo.net/">https://www.Videvo.net/</a><br>mixkit:<a href="https://wedistill.io/">https://wedistill.io/</a></p><h3 id="4-音频："><a href="#4-音频：" class="headerlink" title="4.音频："></a>4.音频：</h3><p>audionautix:<a href="https://audionautix.com/">https://audionautix.com/</a><br>Freepped:<a href="https://freespund.org/">https://freespund.org/</a><br>耳聆网：<a href="https://www.ear0.com/">https://www.ear0.com/</a><br>淘声网：<a href="https://www.tosound.com/">https://www.tosound.com/</a></p></li></ol><p>​    </p><p>​    </p><p>​    </p><p>​    </p><p>​    </p><p>​    </p><p>​    </p><p>​    </p><p>​    </p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 资源整理 </category>
          
          <category> 常用下载 </category>
          
          <category> 节约时间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
            <tag> 常用下载 </tag>
            
            <tag> 扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习Git使用</title>
      <link href="posts/48926450.html"/>
      <url>posts/48926450.html</url>
      
        <content type="html"><![CDATA[<h1 id="git使用学习"><a href="#git使用学习" class="headerlink" title="git使用学习"></a>git使用学习</h1><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><h3 id="1-windows"><a href="#1-windows" class="headerlink" title="1. windows"></a>1. windows</h3><ul><li>安装客户端<ul><li>终端客户端：<a href="https://git-scm.com/">https://git-scm.com/</a></li><li>图形化客户端：<a href="https://tortoisegit.org/">https://tortoisegit.org/</a></li></ul></li><li>配置环境变量<ul><li>变量名：<code>Git_HOME</code></li><li>变量值：<code>D:\Program Files\Git</code></li><li>Path：<code>%Git_HOME%\bin;</code></li></ul></li></ul><h2 id="二、Git-的配置"><a href="#二、Git-的配置" class="headerlink" title="二、Git 的配置"></a>二、Git 的配置</h2><p>整理了一些常用的 Git 配置操作。</p><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux"># 查看全局配置列表git config --global -l# 查看局部配置列表git config --local -l# 查看已设置的全局用户名/邮箱git config --global --get user.namegit config --global --get user.email# 设置全局用户名/邮箱git config --global user.name "输入你的用户名"git config --global user.email "输入你的邮箱"# 设置本地当前工作区仓库用户名/邮箱git config --local user.name "输入你的用户名"git config --local user.email "输入你的邮箱"# 删除配置git config --unset --global user.namegit config --unset --global user.email# 文件权限的变动也会视为改动, 可通过以下配置忽略文件权限变动git config core.fileMode false# 文件大小写设为敏感, git默认是忽略大小写git config --global core.ignorecase false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、初始化仓库"><a href="#三、初始化仓库" class="headerlink" title="三、初始化仓库"></a>三、初始化仓库</h2><p>即新建一个工程，将它关联上 GitHub 上的仓库，最后提交这个新建的工程到 GitHub 中。</p><h3 id="1-前置工作"><a href="#1-前置工作" class="headerlink" title="1. 前置工作"></a>1. 前置工作</h3><p>在 Gitee 上手动创建一个仓库，比如名字叫<strong>CodeChengCompany</strong>。</p><h3 id="2-操作步骤"><a href="#2-操作步骤" class="headerlink" title="2. 操作步骤"></a>2. 操作步骤</h3><h2 id="git上传本地项目文件步骤-实操一下"><a href="#git上传本地项目文件步骤-实操一下" class="headerlink" title="git上传本地项目文件步骤(实操一下)"></a>git上传本地项目文件步骤(实操一下)</h2><pre class="line-numbers language-none"><code class="language-none">依次在本地执行如下的命令：bash# 如果本地已经新建好了 CodeChengCompany 目录，则跳过该命令，直接 cd 到 hello-world 目录下mkdir CodeChengCompany# 进入目标工程的根目录cd CodeChengCompany# 初始化本地仓库：会在当前目录生成 .git 隐藏项目git init# 提交时转换成 unix 风格的换行符，检出时不转换（看各人习惯设置）git config --global core.autocrlf input# 添加要 push 到远程仓库的文件或文件夹（全部就写 git add .）git add xxx# 提交文件到本地库git commit -m "first commit"# 关联远程仓库git remote add origin https://gitee.com/ck_cheng/code-cheng-company.git# 将本地仓库 push 到远程仓库git push -u origin master                                  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写的静态页面：地址：<a href="https://gitee.com/ck_cheng/code-cheng-company.git">https://gitee.com/ck_cheng/code-cheng-company.git</a></p><p><img src="https://codecheng-1305009997.cos.ap-chengdu.myqcloud.com/img/20210416183151.png"></p><h2 id="1-git-init"><a href="#1-git-init" class="headerlink" title="1.git init"></a>1.git init</h2><p>成功后会出现一个 .git 的隐藏文件夹</p><h2 id="2-git-add-代表所有文件都添加"><a href="#2-git-add-代表所有文件都添加" class="headerlink" title="2.git add . //      .代表所有文件都添加"></a>2.git add . //      .代表所有文件都添加</h2><p>添加到缓存区</p><h2 id="3-git-commit-m-“版本号”"><a href="#3-git-commit-m-“版本号”" class="headerlink" title="3.git commit -m “版本号”"></a>3.git commit -m “版本号”</h2><p> 引号里面是备注信息，随便写</p><h2 id="4-gitee-新建仓库"><a href="#4-gitee-新建仓库" class="headerlink" title="4.gitee 新建仓库"></a>4.gitee 新建仓库</h2><p>关联远程仓库，最好创建一个和文件夹同名的仓库</p><h2 id="5-git-remote-add-origin-仓库地址"><a href="#5-git-remote-add-origin-仓库地址" class="headerlink" title="5.git remote add origin + 仓库地址"></a>5.git remote add origin + 仓库地址</h2><p>复制地址，执行关联命令</p><h2 id="6-git-pull-–rebase-origin-master"><a href="#6-git-pull-–rebase-origin-master" class="headerlink" title="6. git pull –rebase origin master"></a>6. git pull –rebase origin master</h2><p>如果 gitee 仓库创建的额时候有 README.MD 文件，则先拉取代码，如果仓库是空的则跳过。</p><h2 id="7-git-push-u-origin-master"><a href="#7-git-push-u-origin-master" class="headerlink" title="7.git push -u origin master"></a>7.git push -u origin master</h2><p>提交到远程仓库</p><h3 id="最后查看仓库即可"><a href="#最后查看仓库即可" class="headerlink" title="最后查看仓库即可"></a>最后查看仓库即可</h3><h2 id="注意要点和一些总结"><a href="#注意要点和一些总结" class="headerlink" title="注意要点和一些总结"></a>注意要点和一些总结</h2><p>在实践过程中，由于在 Gitee 上手动创建的仓库包括：README.md 文件，而本地仓库没有此文件，则在执行 <code>git push -u origin master</code> 命令前，需要先做如下两步：</p><p>第一步：可以通过如下命令进行代码合并【注：pull = fetch + merge】。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bashgit pull --rebase origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行上面代码后可以看到本地代码库中多了 README.md 文件。</p><p>第二步：此时再执行语句 <code>git push -u origin master</code> 即可完成代码上传到 Gitee.</p><h2 id="四、克隆仓库"><a href="#四、克隆仓库" class="headerlink" title="四、克隆仓库"></a>四、克隆仓库</h2><p>即将 Gitee 上的代码下载到本地，注意不是简单的 Download ZIP，那样下载的代码没有与远程仓库建立关联，无法做版本维护。</p><p>这里用的命令就是 <code>clone</code>。</p><pre class="line-numbers language-none"><code class="language-none"># https 协议git clone https://gitee.com/ck_cheng/code-cheng-company.git# SSH 协议（一般不用）git clone git@gitee.com:yourGitheeID/CodechengCompany.git# 克隆指定分支， -b 指定分支名字，实际上是克隆所有分支并切换到 develop 分支上git clone -b develop https://gitee.com/ck_cheng/code-cheng-company.git# --single-branch 完全只克隆指定分支git clone -b develop --single-branch https://gitee.com/ck_cheng/code-cheng-company.git# 指定克隆后的文件夹名称git clone https://gitee.com/ck_cheng/code-cheng-company.git new-Code-cheng-Company# 克隆深度为1，只克隆指定分支，历史记录只克隆最后一条，减少克隆时间git clone --depth=1 https://gitee.com/ck_cheng/code-cheng-company.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、查看工作区状态"><a href="#五、查看工作区状态" class="headerlink" title="五、查看工作区状态"></a>五、查看工作区状态</h2><p>查看本地工作区的状态。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bash# 查看当前工作区暂存区变动，等同 git status --longgit status# 以短格式给出输出git status -s# 显示已忽略的文件git status --ignored# 查询工作区中是否有 stash 存在（暂存的东西），有则提醒该工作区有几个 stashgit status --show-stash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、查看日志"><a href="#六、查看日志" class="headerlink" title="六、查看日志"></a>六、查看日志</h2><p>查看日志，经常用的命令。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bash# 查看完整历史提交记录git log# 查看前 N 次提交记录git log -2# 查看前 N 次提交记录，包括 diffgit log -p -2# 查看指定作者历史记录git log --author=&lt;your_name&gt;# 查看指定文件的历史提交记录git log &lt;file&gt;# 只显示合并日志git log --merges# 以图形查看日志记录，--oneline 可选，表示输出概要日志git log --graph --oneline# 列出提交者代码贡献数量，打印作者和贡献数量git shortlog -sn# 以提交贡献数量排序并打印出 messagegit shortlog -n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、分支操作"><a href="#七、分支操作" class="headerlink" title="七、分支操作"></a>七、分支操作</h2><h3 id="1-查看分支"><a href="#1-查看分支" class="headerlink" title="1. 查看分支"></a>1. 查看分支</h3><pre class="line-numbers language-none"><code class="language-none"># 查看所有分支git branch -a# 查看本地分支git branch# 查看远端分支git branch -r# 查看本地分支所关联的远程分支git branch -vv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-删除分支"><a href="#2-删除分支" class="headerlink" title="2. 删除分支"></a>2. 删除分支</h3><p>比较常用的是删除本地分支，重命名分支，删除远程分支。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bash# 删除本地分支，参数 -d 若是大写就等同多了--force，强制执行git branch -d &lt;branch_name&gt;# 移动或者重命名本地分支，参数 -m 若是大写就等同多了--force，强制执行git branch -m &lt;old_branch_name&gt; &lt;new_branch_name&gt;# 删除远程分支git push origin -d &lt;branch_name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-切换分支"><a href="#3-切换分支" class="headerlink" title="3. 切换分支"></a>3. 切换分支</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bash# 切换到某一个本地分支git checkout &lt;branch_name&gt;# 切换远端分支（通常是本地没有远端的分支记录才会使用此命令，反之不建议）git checkout --track origin/&lt;branch_name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-合并分支"><a href="#4-合并分支" class="headerlink" title="4. 合并分支"></a>4. 合并分支</h3><p>合并分支的操作一般借助可视化工具来做，纯命令的方式我不太熟练。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bash# 将 feature/v1.0.0 分支代码合并到 developgit checkout developgit merge feature/v1.0.0# 以安静模式合并，把 develop 分支合并到当前分支并不输出任何信息git merge develop -q# 合并不编辑消息，跳过交互git merge develop --no-edit# 合并分支后不进行提交git merge develop --no-commit# 退出合并，恢复到合并之前的状态git merge --abort<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="八、文件暂存"><a href="#八、文件暂存" class="headerlink" title="八、文件暂存"></a>八、文件暂存</h2><p>应用场景：在当前分支开发时，临时需要切换到其他分支修改 Bug，但此时又不想提交当前分支上开发到一半的代码（切换分支必须把当前工作内容提交，否则无法切换），这个时候就可以用到 <code>git stash</code>。</p><p>强烈建议给每个 stash 添加描述信息！！！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bash# 暂存当前工作区内容git stash# 暂存时添加描述信息，推荐使用此命令git stash push -m "更改了 xx"# 暂存包含没有被 Git 追踪的文件git stash -u# 查看当前暂存列表git stash list# 恢复修改工作区内容, 会从 git stash list 移除掉git stash pop # 恢复最近一次保存内容到工作区，默认会把暂存区的改动恢复到工作区git stash pop stash@{1} # 恢复指定 id， 通过 git stash list 可查到# 与 pop 命令一致，唯一不同的是不会从 git stash list 移除掉git stash apply# 清空所有保存（慎用）git stash clear# 清空指定 stash id, 如果 drop 后面不指定 id 则清除最近的一次git stash drop stash@{0}git stash drop  # 清除最近一次# 想看 stash 做了什么改动，类似简化版的 git diffgit stash show stash@{0}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="九、查看文件-diff"><a href="#九、查看文件-diff" class="headerlink" title="九、查看文件 diff"></a>九、查看文件 diff</h2><p><code>git diff</code> 命令用于查看文件内容之间差异，对于这个命令，在终端比对用的不是很频繁，除了少量改动的时侯可能会用这个看看。</p><p>其他情况下我更倾向于用可视化工具来看，因为比对更加直观。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bash# 比较所有文件工作区与暂存区的差异git diff# 比较指定文件工作区与暂存区差异git diff &lt;file&gt;# 比较两次提交之间的差异git diff &lt;commit_id1&gt; &lt;commit_id2&gt;# 显示出所有有差异的文件的详细差异git diff &lt;branch1&gt; &lt;branch2&gt;# 将 diff 结果打印到文件git diff --color master &gt; a.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十、代码回滚（reset-revert）"><a href="#十、代码回滚（reset-revert）" class="headerlink" title="十、代码回滚（reset/revert）"></a>十、代码回滚（reset/revert）</h2><h3 id="1-reset-方式"><a href="#1-reset-方式" class="headerlink" title="1. reset 方式"></a>1. reset 方式</h3><p>代码回滚中这个命令也是用的很多，而且是 –hard 用的比较多。</p><p>–hard：硬性回滚，简单粗暴，直接抛弃上次提交后的所有本次修改，回滚到之前的样子<br>–soft：软性回滚，可以理解为撤销指定的 commit 记录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bash# 回滚上一个版本git reset --hard HEAD^# 回滚上两个版本git reset --hard HEAD^^# 回滚到指定 commit_id，通过 git log 查看git reset --hard &lt;commit_id&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果需要撤销已经 push 到远端的 commit，使远端的仓库也回退到相应的版本，需要在 push 时加上参数 –force：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bashgit push origin &lt;分支名&gt; --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-revert-方式（优雅）"><a href="#2-revert-方式（优雅）" class="headerlink" title="2. revert 方式（优雅）"></a>2. revert 方式（优雅）</h3><p><code>git revert</code> 撤销某次提交后，它会产生一个新的提交，虽然代码回退了，但是版本依然是向前的，所以，当你用 revert 回退之后，所有人 pull 之后，他们的代码也自动的回退了。</p><pre class="line-numbers language-none"><code class="language-none"># 恢复某次提交的状态，恢复动作本身也创建了一次提交对象git revert &lt;commit_id&gt;# 恢复最后一次提交的状态git revert HEAD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，要注意以下几点：</p><ul><li>revert 是撤销一次提交，所以后面的 commit_id 是你需要回滚到的版本的上一次提交；</li><li>使用 <code>revert HEAD</code> 是撤销最近的一次提交，如果你最近一次提交是用 revert 命令产生的，那么你再执行一次，就相当于撤销了上次的撤销操作，换句话说，你连续执行两次 <code>revert HEAD</code> 命令，就跟没执行是一样的；</li><li>使用 <code>revert HEAD~1</code> 表示撤销最近 2 次提交，这个数字是从 0 开始的，如果你之前撤销过产生了 commit_id，那么也会计算在内的；</li><li>如果使用 revert 撤销的不是最近一次提交，那么一定会有代码冲突，需要你合并代码，合并代码只需要把当前的代码全部去掉，保留之前版本的代码就可以了。</li></ul><p><code>git revert</code> 命令的好处就是不会丢掉别人的提交，即使你撤销后覆盖了别人的提交，他更新代码后，可以在本地用 reset 向前回滚，找到自己的代码，然后拉一下分支，再回来合并上去就可以找回被你覆盖的提交了。</p><h3 id="3-reset-和-revert-区别"><a href="#3-reset-和-revert-区别" class="headerlink" title="3. reset 和 revert 区别"></a>3. reset 和 revert 区别</h3><ul><li><code>git revert</code> 是用一次新的 commit 来回滚之前的 commit，<code>git reset</code> 是直接删除指定的 commit。</li><li>在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别。因为 <code>git revert</code> 是用一次逆向的 commit「中和」之前的提交，因此日后合并老的 branch 时，导致这部分改变不会再次出现，但是 <code>git reset</code> 是直接把某些 commit 在某个 branch 上删除，因而和老的 branch 再次 merge 时，这些被回滚的 commit 应该还会被引入。</li><li><code>git reset</code> 是把 HEAD 向后移动了一下，而 <code>git revert</code> 是 HEAD 继续前进，只是新的 commit 的内容和要 revert 的内容正好相反，能够抵消要被 revert 的内容。</li></ul><h2 id="十一、管理远程仓库"><a href="#十一、管理远程仓库" class="headerlink" title="十一、管理远程仓库"></a>十一、管理远程仓库</h2><p>通常使用 <code>git remote</code> 命令来管理远程仓库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bash# 查看远程仓库服务器，一般打印 origin，这是 Git 给你克隆的仓库服务器的默认名字# 一般只会显示 origin，除非你有多个远程仓库地址git remote# 指定-v, 查看当前仓库地址git remote -v# 添加远程仓库地址 example 是自定义名字# 添加完后可以通过 git remote 就能看到 examplegit remote add example https://gitee.com/ck_cheng/code-cheng-company.git# 查看指定远程仓库信息git remote show &lt;branch_name&gt;# 重命名远程仓库git remote rename &lt;old_branch_name&gt; &lt;new_branch_name&gt;# 移除远程仓库git remote remove &lt;branch_name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 分布式版本控制 </category>
          
          <category> Gitee </category>
          
          <category> 基本技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 部署项目 </tag>
            
            <tag> 基本技能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Andriod学习笔记</title>
      <link href="posts/b191fb6f.html"/>
      <url>posts/b191fb6f.html</url>
      
        <content type="html"><![CDATA[<h1 id="Andirod学习笔记（一）"><a href="#Andirod学习笔记（一）" class="headerlink" title="Andirod学习笔记（一）"></a>Andirod学习笔记（一）</h1><h2 id="移动开发学习路线图"><a href="#移动开发学习路线图" class="headerlink" title="移动开发学习路线图"></a>移动开发学习路线图</h2><p>按照这个来学习基础知识，基本上完成安卓基础知识</p><p><img src="https://atts.w3cschool.cn/attachments/image/cimg/2015-12-01_565da596dd46d.jpg"></p><h1 id="Andirod系统架构"><a href="#Andirod系统架构" class="headerlink" title="Andirod系统架构"></a>Andirod系统架构</h1><blockquote><p>Android 操作系统是一个软件组件的栈，在架构图中它大致可以分为五个部分和四个主要层。</p></blockquote><p><img src="https://www.runoob.com/wp-content/uploads/2015/06/android_architecture.jpg"></p><h3 id="1-Linux内核层"><a href="#1-Linux内核层" class="headerlink" title="1.Linux内核层"></a>1.Linux内核层</h3><p>它提供了基本的系统功能，比如<strong>进程管理，内存管理，设备管理（如摄像头，键盘，显示器</strong>,<strong>显示驱动，音频驱动。WiFi驱动，电源管理</strong>）。同时，内核处理所有 Linux 所擅长的工作，如网络和大量的设备驱动，从而避免兼容大量外围硬件接口带来的不便。</p><h3 id="2-系统运行库层"><a href="#2-系统运行库层" class="headerlink" title="2.系统运行库层"></a>2.系统运行库层</h3><h3 id="3-应用框架层"><a href="#3-应用框架层" class="headerlink" title="3.应用框架层"></a>3.应用框架层</h3><h3 id="4-应用层"><a href="#4-应用层" class="headerlink" title="4.应用层"></a>4.应用层</h3><h1 id="Android-应用程序四大组件"><a href="#Android-应用程序四大组件" class="headerlink" title="Android 应用程序四大组件"></a>Android 应用程序四大组件</h1><p>应用程序组件是一个Android应用程序的基本构建块。这些组件由应用清单文件松耦合的组织。AndroidManifest.xml描述了应用程序的每个组件，以及他们如何交互。</p><p>以下是可以在Android应用程序中使用的四个主要组件。</p><table><thead><tr><th align="left">组件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Activities</td><td align="left">描述UI，并且处理用户与机器屏幕的交互。</td></tr><tr><td align="left">Services</td><td align="left">处理与应用程序关联的后台操作。</td></tr><tr><td align="left">Broadcast Receivers</td><td align="left">处理Android操作系统和应用程序之间的通信。</td></tr><tr><td align="left">Content Providers</td><td align="left">处理数据和数据库管理方面的问题。</td></tr></tbody></table><h1 id="Android-Studio配置"><a href="#Android-Studio配置" class="headerlink" title="Android Studio配置"></a>Android Studio配置</h1><blockquote><p> Setting配置</p></blockquote><p><img src="https://codecheng-1305009997.cos.ap-chengdu.myqcloud.com/img/image-20210410160715810.png"></p><p>1、Appearancebehavior：外观与行为</p><p>2、Keymap：快捷键</p><p>3、Editor：编辑</p><p>4、Plugins：插件</p><p>5、VerSion COntrol：版本控制</p><p>6、Build、Excution、Deploypent：编译、运行、发布</p><p>7、Languages Frameworks：语言和框架</p><p>8、Tools：工具</p><p>9、Other Settings：其他设置</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>【Android Studio的优势】</p><ul><li>基于Gradle的构建支持</li><li>Android特定重构和快速修复</li><li>更加丰富的模板代码，让创建程序更简单</li><li>提示工具更好地对程序性能、可用性、版本兼容和其他问题进行控制捕捉</li><li>直接支持ProGuard和应用签名功能；</li><li>自带布局编辑器，可以让你拖放UI组件，并在多个屏幕配置上预览布局等；</li><li>内置Google云支持；</li><li>内置svn、git工具支持；</li><li>支持插件，eclipse有的，Android Studio里基本都能找到。</li><li>2.0之后，支持NDK了。</li></ul><h1 id="安卓项目目录结构"><a href="#安卓项目目录结构" class="headerlink" title="安卓项目目录结构"></a>安卓项目目录结构</h1><p><img src="https://codecheng-1305009997.cos.ap-chengdu.myqcloud.com/img/20210412110635.png"></p><p>详解：</p><ol><li><p>.gradle和.idea</p><blockquote><p>放置的是Andriod studio 自动生成的一些文件，不用管，也不要手动编辑</p></blockquote></li><li><p>bulid</p><blockquote><p>不需要过多的担心，主要包含一些在编译时生成得的文件。</p></blockquote></li><li><p>gradle</p><blockquote><p>包含了gradle wrapper的配置文件，使用gradle wrapper 的方式不需要提前将gradle下载好，而是会自动根据本地缓存情况决定是否需要联网下载gradle。</p></blockquote></li><li><p>.gitignore</p><blockquote><p>用来将指定的目录或文件排除在版本控制之外的</p></blockquote></li><li><p>bulid.gradle</p><blockquote><p>这个是项目全局的gradle构建脚本，通常这个文件的内容是不需要修改的。</p></blockquote></li><li><p>gradle.properties</p><blockquote><p>这个文件是全局的gradle配置文件，在这里配置的属性将会影响到项目中所有的gradle编译脚本</p></blockquote></li><li><p>gradlew和gradlew.bat</p><blockquote><p>在命令行界面使用，gradlew在liunx  gradlew.bat在Windows中使用</p></blockquote></li><li><p>local.properties</p><blockquote><p>用于指定本集中的Andriod SDK 路径，内容自动生成，不需要修改</p></blockquote></li><li><p>setting.gradle</p><blockquote><p>指定项目中所有引入的模块。</p></blockquote></li></ol><h1 id="Andriod项目结构"><a href="#Andriod项目结构" class="headerlink" title="Andriod项目结构"></a>Andriod项目结构</h1><h2 id="1-工程项目结构解析："><a href="#1-工程项目结构解析：" class="headerlink" title="1.工程项目结构解析："></a>1.工程项目结构解析：</h2><p>我们开发大部分时间都花在下面这个部分上：</p><p><img src="https://atts.w3cschool.cn/attachments/image/cimg/2015-12-01_565da5d85f3ce.jpg" alt="img"></p><p>关键部分详解：</p><blockquote><ul><li><strong>java：</strong>我们写Java代码的地方，业务功能都在这里实现</li><li><strong>res：</strong>存放我们各种资源文件的地方，有图片，字符串，动画，音频等，还有各种形式的XML文件</li><li><strong>drawable：</strong>存放的是各种位图文件，还有一些其他的drawable类型的xml文件。</li><li><strong>layout：</strong>存放APP的布局文件。</li><li><strong>mipmap：</strong>存放位图文件，同时图片缩放提供一定优化。</li><li>value：包括了colors.xml，strings.xml，styles.xml这三个主要文件，其中colors.xml中定义的颜色资源；strings.xml中定义的字符串资源；styles.xml中定义的是样式资源。</li></ul></blockquote><hr><h3 id="1-res资源文件夹介绍："><a href="#1-res资源文件夹介绍：" class="headerlink" title="1.res资源文件夹介绍："></a>1.res资源文件夹介绍：</h3><p>PS：说到这个<strong>res目录</strong>，另外还有提下这个<strong>assets目录</strong>，虽然这里没有，但是我们可以自己创建，两者的区别在于是否前者下所有的资源文件都会在R.java文件下生成对应的资源id，而后者并不会；前者我们可以直接通过资源id访问到对应的资源；而后者则需要我们通过AssetManager以二进制流的形式来读取！对了，这个R文件可以理解为字典，res下每个资源都都会在这里生成一个唯一的id！</p><p>接着说下res这个资源目录下的相关目录：</p><p><strong>PS:<strong>下述mipmap的目录，在Eclipse并不存在这个，Eclipse中都是drawable开头的，其实区别不大，只是使用mipmap会在图片缩放在提供一定的性能优化，分辨率不同系统会根据屏幕分辨率来选择hdpi，mdpi，xmdpi，xxhdpi下的对应图片，所以你解压别人的apk可以看到上述目录同一名称的图片，在</strong>四个文件夹</strong>下都有，只是大小和像素不一样而已！当然,这也不是绝对的,比如我们把所有的图片都丢在了drawable-hdpi下的话,即使手机 本该加载ldpi文件夹下的图片资源,但是ldpi下没有,那么加载的还会是hdpi下的图片! 另外,还有一种情况:比如是hdpi,mdpi目录下有,ldpi下没有,那么会加载mdpi中的资源! 原则是使用最接近的密度级别!另外如果你想禁止Android不跟随屏幕密度加载不同文件夹的资源,只需在AndroidManifest.xml文件中添加android:anyDensity=”false”字段即可!</p><p>1.先说下<strong>图片</strong>资源：</p><blockquote><ul><li><strong>drawable：</strong>存放各种位图文件，(.png，.jpg，.9png，.gif等)除此之外可能是一些其他的drawable类型的XML文件</li><li><strong>mipmap-hdpi：</strong>高分辨率，一般我们把图片丢这里</li><li><strong>mipmap-mdpi：</strong>中等分辨率，很少，除非兼容的的手机很旧</li><li><strong>mipmap-xhdpi：</strong>超高分辨率，手机屏幕材质越来越好，以后估计会慢慢往这里过渡</li><li><strong>mipmap-xxhdpi：</strong>超超高分辨率，这个在高端机上有所体现</li></ul></blockquote><p>2.接着说下<strong>布局</strong>资源：</p><blockquote><ul><li>layout：该目录下存放的就是我们的布局文件，另外在一些特定的机型上，我们做屏幕适配，比如480*320这样的手机，我们会另外创建一套布局，就行：layout-480x320这样的文件夹！</li></ul></blockquote><p>3.接下来说下菜单资源：</p><blockquote><ul><li><strong>menu：</strong>在以前有物理菜单按钮，即menu键的手机上，用的较多，现在用的并不多，菜单项相关的资源xml可在这里编写，不知道谷歌会不会出新的东西来替代菜单了~</li></ul></blockquote><p>4.接下来说下values目录：</p><blockquote><ul><li>demens.xml：定义尺寸资源</li><li>string.xml：定义字符串资源</li><li>styles.xml：定义样式资源</li><li>colors.xml：定义颜色资源</li><li>arrays.xml：定义数组资源</li><li>attrs.xml：自定义控件时用的较多，自定义控件的属性！</li><li>theme主题文件，和styles很相似，但是会对整个应用中的Actvitiy或指定Activity起作用，一般是改变窗口外观的！可在Java代码中通过setTheme使用，或者在Androidmanifest.xml中为添加theme的属性！ PS:你可能看到过这样的values目录：values-w820dp，values-v11等，前者w代表平板设备，820dp代表屏幕宽度；而v11这样代表在API(11)，即android 3.0后才会用到的！</li></ul></blockquote><p>5.在接着说下这个raw目录： 用于存放各种原生资源(音频，视频，一些XML文件等)，我们可以通过openRawResource(int id)来获得资源的二进制流！其实和Assets差不多，不过这里面的资源会在R文件那里生成一个资源id而已</p><p>6.最后还有个动画的，动画有两种：属性动画和补间动画：</p><blockquote><ul><li>animator：存放属性动画的XML文件</li><li>anim：存放补间动画的XML文件</li></ul></blockquote><hr><h3 id="2-如何去使用这些资源"><a href="#2-如何去使用这些资源" class="headerlink" title="2.如何去使用这些资源"></a>2.如何去使用这些资源</h3><p>嗯，知道有什么资源，接下来就来了解该怎么用了： 前面也说了，我们所有的资源文件都会在R.java文件下生成一个资源id，我们可以通过这个资源id来完成资源的访问，使用情况有两种：Java代码中使用和XML代码中使用： <strong>Java代码中使用：</strong></p><pre class="line-numbers language-none"><code class="language-none">Java 文字：txtName.setText(getResources().getText(R.string.name)); 图片：imgIcon.setBackgroundDrawableResource(R.drawable.icon); 颜色：txtName.setTextColor(getResouces().getColor(R.color.red)); 布局：setContentView(R.layout.main);控件：txtName = (TextView)findViewById(R.id.txt_name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>XML代码中使用：</strong></p><p>通过@xxx即可得到，比如这里获取文本和图片:</p><pre class="line-numbers language-none"><code class="language-none">&lt;TextView android:text="@string/hello_world" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background = "@drawable/img_back"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="2-深入了解三个文件："><a href="#2-深入了解三个文件：" class="headerlink" title="2.深入了解三个文件："></a>2.深入了解三个文件：</h2><p>好了，接下来我们就要剖析工程里三个比较重要的文件： MainActivity.java，布局文件：activity_main和Android配置文件：AndroidManifest.xml <strong>PS：</strong>图片内容可能有点差距，没时间做图，望体谅~</p><p><img src="https://atts.w3cschool.cn/attachments/image/20200727/1595814173502872.png" alt="img"></p><h3 id="布局文件：activity-main-xml："><a href="#布局文件：activity-main-xml：" class="headerlink" title="布局文件：activity_main.xml："></a>布局文件：activity_main.xml：</h3><p>代码如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="match_parent"    tools:context=".MainActivity"&gt;    &lt;TextView        android:layout_width="wrap_content"        android:layout_height="wrap_content"        android:text="@string/hello_world" /&gt;&lt;/RelativeLayout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 移动应用开发 </category>
          
          <category> Andriod </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Andriod </tag>
            
            <tag> 移动应用开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML学习笔记</title>
      <link href="posts/30463f21.html"/>
      <url>posts/30463f21.html</url>
      
        <content type="html"><![CDATA[<h1 id="XML学习笔记"><a href="#XML学习笔记" class="headerlink" title="XML学习笔记"></a>XML学习笔记</h1><h3 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a><strong>XML简介</strong></h3><p>XML，可扩展的标识语言（eXtensible Markup Language），XML 被设计用来传输和存储数据。</p><p>HTML 被设计用来显示数据。</p><blockquote><p> <strong>提示：</strong>XML 是可扩展标记语言，HTML 为超文本标记语言。</p></blockquote><h3 id="XML作用"><a href="#XML作用" class="headerlink" title="XML作用"></a><strong>XML作用</strong></h3><ul><li>丰富文件（Rich Documents）-自定文件描述并使其更丰富；</li><li>属于文件为主的XML技术应用；</li><li>标记是用来定义一块数据应该如何呈现；</li><li>解释数据（Metadata）-描述其它文件或在线信息；</li><li>属于数据为主的XML技术应用；</li><li>标记是用来说明一块资料的意义；</li><li>组态档案（Configuration Files）-描述软件的组态参数。</li></ul><h3 id="XML不是对HTML的替代"><a href="#XML不是对HTML的替代" class="headerlink" title="XML不是对HTML的替代"></a><strong>XML不是对HTML的替代</strong></h3><p>XML 是对 HTML 的补充。</p><p>XML 不会替代 HTML，理解这一点很重要。在大多数 Web 应用程序中，XML 用于传输数据，而 HTML 用于格式化并显示数据。</p><p>对 XML 最好的描述是：</p><p>XML 是独立于软件和硬件的信息传输工具。</p><p>XML 被设计用来结构化、存储以及传输信息。</p><p>自己写给自己，下面实例是 CodeCheng写给 小Dai 的便签，存储为 XML：    </p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>note</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>to</span><span class="token punctuation">&gt;</span></span>小Dai<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>to</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span><span class="token punctuation">&gt;</span></span>CodeCheng<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>from</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heading</span><span class="token punctuation">&gt;</span></span>Reminder<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heading</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>2021,要加油呀<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>note</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的这条便签具有自我描述性。它包含了发送者和接受者的信息，同时拥有标题以及消息主体。</p><p>但是，这个 XML 文档仍然没有做任何事情。它仅仅是包装在 XML 标签中的纯粹的信息。我们需要编写软件或者程序，才能传送、接收和显示出这个文档。</p><h2 id="通过-XML-可以自定义标签"><a href="#通过-XML-可以自定义标签" class="headerlink" title="通过 XML 可以自定义标签"></a>通过 XML 可以自定义标签</h2><p>上面实例中的标签没有在任何 XML 标准中定义过（比如 <to> 和 <from>）。这些标签是由 XML 文档的创作者发明的。</from></to></p><p>这是因为 XML 语言没有预定义的标签。</p><p>HTML 中使用的标签都是预定义的。HTML 文档只能使用在 HTML 标准中定义过的标签（如 </p><p>、</p><h1> 等等）。<p></p><ul><li><p><strong><u>XML 允许创作者定义自己的标签和自己的文档结构。</u></strong></p></li><li><p><strong>XML 是对 HTML 的补充。</strong></p></li></ul><p>对 XML 最好的描述是：</p><ul><li><blockquote><p><strong>XML 是独立于软件和硬件的信息传输工具。</strong></p></blockquote></li></ul></h1><h2 id="XML-是-W3C-的推荐标准"><a href="#XML-是-W3C-的推荐标准" class="headerlink" title="XML 是 W3C 的推荐标准"></a>XML 是 W3C 的推荐标准</h2><p>XML 于 1998 年 2 月 10 日成为 W3C 的推荐标准。</p><h2 id="XML-无所不在"><a href="#XML-无所不在" class="headerlink" title="XML 无所不在"></a>XML 无所不在</h2><p>目前，XML 在 Web 中起到的作用不会亚于一直作为 Web 基石的 HTML。</p><p>XML 是各种应用程序之间进行数据传输的最常用的工具。</p><h3 id="XML的用法"><a href="#XML的用法" class="headerlink" title="XML的用法"></a>XML的用法</h3><h2 id="XML-把数据从-HTML-分离"><a href="#XML-把数据从-HTML-分离" class="headerlink" title="XML 把数据从 HTML 分离"></a>XML 把数据从 HTML 分离</h2><p>如果你需要在 HTML 文档中显示动态数据，那么每当数据改变时将花费大量的时间来编辑 HTML。</p><p>通过 XML，数据能够存储在独立的 XML 文件中。这样您就可以专注于使用 HTML/<a href="https://www.w3cschool.cn/css/css-tutorial.html">CSS</a> 进行显示和布局，并确保修改底层数据不再需要对 HTML 进行任何的改变。</p><p>通过使用几行 JavaScript代码，你就可以读取一个外部 XML 文件，并更新网页的数据内容。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>W3Cschool在线教程(w3cschool.cn)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">function</span> <span class="token function">displayDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"demo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>我的第一个 JavaScript 程序<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>demo<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>这是一个段落<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>displayDate()<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>显示日期<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="XML-简化数据共享"><a href="#XML-简化数据共享" class="headerlink" title="XML 简化数据共享"></a>XML 简化数据共享</h3><p>在真实的世界中，计算机系统和数据使用不兼容的格式来存储数据。</p><p>XML 数据以纯文本格式进行存储，因此提供了一种独立于软件和硬件的数据存储方法。</p><p>这让创建不同应用程序可以共享的数据变得更加容易。</p><hr><h3 id="XML-简化数据传输"><a href="#XML-简化数据传输" class="headerlink" title="XML 简化数据传输"></a>XML 简化数据传输</h3><p>对开发人员来说，其中一项最费时的挑战一直是在互联网上的不兼容系统之间交换数据。</p><p>由于可以通过各种不兼容的应用程序来读取数据，以 XML 交换数据降低了这种复杂性。</p><hr><h3 id="XML-简化平台变更"><a href="#XML-简化平台变更" class="headerlink" title="XML 简化平台变更"></a>XML 简化平台变更</h3><p>升级到新的系统（硬件或软件平台），总是非常费时的。必须转换大量的数据，不兼容的数据经常会丢失。</p><p>XML 数据以文本格式存储。这使得 XML 在不损失数据的情况下，更容易扩展或升级到新的操作系统、新的应用程序或新的浏览器。</p><hr><h3 id="XML-使你的数据更有用"><a href="#XML-使你的数据更有用" class="headerlink" title="XML 使你的数据更有用"></a>XML 使你的数据更有用</h3><p>不同的应用程序都能够访问您的数据，不仅仅在 HTML 页中，也可以从 XML 数据源中进行访问。</p><p>通过 XML，您的数据可供各种阅读设备使用（掌上计算机、语音设备、新闻阅读器等），还可以供盲人或其他残障人士使用。</p><hr><h3 id="XML-用于创建新的互联网语言"><a href="#XML-用于创建新的互联网语言" class="headerlink" title="XML 用于创建新的互联网语言"></a>XML 用于创建新的互联网语言</h3><p>很多新的互联网语言是通过 XML 创建的。</p><p>这里有一些实例：</p><ul><li>XHTML</li><li>用于描述可用的 Web 服务 的 WSDL</li><li>作为手持设备的标记语言的 WAP 和 WML</li><li>用于新闻 feed 的 RSS 语言</li><li>描述资本和本体的 RDF 和 OWL</li><li>用于描述针对 Web 的多媒体 的 SMIL</li></ul><h1 id="XML-树结构"><a href="#XML-树结构" class="headerlink" title="XML 树结构"></a>XML 树结构</h1><blockquote><p>XML 文档形成了一种树结构，它从”根部”开始，然后扩展到”枝叶”。</p></blockquote><p>树结构是通常被称为 XML 树，并且可以很容易地描述任何 XML 文档。</p><p>通过采用树状结构，你可以知道所有从根开始的后续的分行及支行。</p><h1 id="XML-语法"><a href="#XML-语法" class="headerlink" title="XML 语法"></a>XML 语法</h1><h2 id="XML-语法规则"><a href="#XML-语法规则" class="headerlink" title="XML 语法规则"></a>XML 语法规则</h2><blockquote><p>很重要哦：</p><ul><li><p>所有的 XML 元素都必须有一个关闭标签</p></li><li><p>XML 标签对大小写敏感</p></li><li><p>XML 必须正确嵌套</p></li><li><p>XML 文档必须有根元素</p></li><li><p>XML 属性值必须加引号</p></li><li><p>实体引用:</p><p>在 XML 中，一些字符拥有特殊的意义。</p><p>如果您把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。</p><ul><li>在 XML 中，空格会被保留</li></ul></li></ul></blockquote><p>在 XML 中，有 5 个预定义的实体引用：</p><table><thead><tr><th>&lt;</th><th>&lt;</th><th>less than</th></tr></thead><tbody><tr><td>&gt;</td><td>&gt;</td><td>greater than</td></tr><tr><td>&amp;</td><td>&amp;</td><td>ampersand</td></tr><tr><td>'</td><td>‘</td><td>apostrophe</td></tr><tr><td>"</td><td>“</td><td>quotation mark</td></tr></tbody></table><p><strong>注释：</strong>在 XML 中，只有字符 “&lt;” 和 “&amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。</p><h2 id="XML-中的注释"><a href="#XML-中的注释" class="headerlink" title="XML 中的注释"></a>XML 中的注释</h2><p>在 XML 中编写注释的语法与 HTML 的语法很相似。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- 这里是注释的内容 --&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="XML-以-LF-存储换行"><a href="#XML-以-LF-存储换行" class="headerlink" title="XML 以 LF 存储换行"></a>XML 以 LF 存储换行</h2><p>在 Windows 应用程序中，换行通常以一对字符来存储：回车符（CR）和换行符（LF）。</p><p>在 Unix 和 Mac OSX 中，使用 LF 来存储新行。</p><p>在旧的 Mac 系统中，使用 CR 来存储新行。</p><p>XML 以 LF 存储换行。</p>]]></content>
      
      
      <categories>
          
          <category> xml </category>
          
          <category> 后端 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络的一些其他的了解</title>
      <link href="posts/c91fe873.html"/>
      <url>posts/c91fe873.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何运行一个网站？"><a href="#如何运行一个网站？" class="headerlink" title="如何运行一个网站？"></a>如何运行一个网站？</h1><h2 id="要运行网站，最基本需要服务器、IP地址、域名、DNS、数据库"><a href="#要运行网站，最基本需要服务器、IP地址、域名、DNS、数据库" class="headerlink" title="要运行网站，最基本需要服务器、IP地址、域名、DNS、数据库"></a>要运行网站，最基本需要服务器、IP地址、域名、DNS、数据库</h2><h3 id="1-服务器："><a href="#1-服务器：" class="headerlink" title="1.服务器："></a>1.服务器：</h3><p>服务器本质上就是一台电脑，不过一般24小时常开，承载并计算网站上的各种数据，所用的CPU跟家用电脑有所不同，以因特尔为例，家用的电脑从奔腾系列到i3i5i7i9，虽然核数有增多，但是主要提升的还是主频，也就是单位时间内计算次数，非X系列的一般不会超过8核。但是服务器CPU主要处理普通数据，需要可靠性和稳定性，因此一般来说核数比较多，主频比较低，缓存更大，指令集更精简。那么可能有人会想，我们自己的电脑能不能变成服务器呢？这个问题下面再阐释。</p><h3 id="2-IP地址"><a href="#2-IP地址" class="headerlink" title="2.IP地址"></a>2.IP地址</h3><p> IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异，也就是每台服务器都有自己的IP地址。用这个唯一的数据地址可以在互联网上千千万万台设备中找到自己要访问的那一台服务器。最初的版本是IPv4，实质是32位二进制数字，为了方便读写每八位化为一个十进制例如255.255.255.1，从它的简写方式我们也能知道每个十进制数字的范围是0~255，因为无符号八位二进制最大值就是255。但2019年11月25日所有的IPv4位地址已经分配完毕（也就是2^32-1个地址），没有新的IPv4地址可分。所以现在正在推进建设IPv6。虽然说IP地址是唯一的，但是这并不是说每台电脑的IP都是唯一的，只能说连接在公网的服务器IP是唯一的，也叫做网关的地址是唯一的，其它内网电脑的IP可根据它来随意设置,前提是IP前三个数要跟它一样,第四个可从0-255中任选但要跟服务器的IP不同。现在一般公网IP是服务商提供网络服务的。内网IP范围一般都是这三个：</p><ul><li> 10.0.0.0~10.255.255.255   </li><li> 172.16.0.0~172.31.255.255 </li><li> 192.168.0.0~192.168.255.255</li></ul><p> 可以查看自己的IP地址来确定是不是内网，如果不在这个范围那么很可能就是公网了，对于上面能不能把自己的电脑变成服务器的问题，如果是公网而且IP地址固定的话是可以的，但是现在电脑设定基本都是动态IP，内网的话需要申请映射到外网IP，不如去买服务器。</p><h3 id="3-域名："><a href="#3-域名：" class="headerlink" title="3.域名："></a>3.域名：</h3><p> 由于IP地址具有不方便记忆并且不能显示地址组织的名称和性质等缺点，人们设计出了域名，并通过网域名称系统（DNS，Domain Name System）来将域名和IP地址相互映射，使人更方便地访问互联网，而不用去记住能够被机器直接读取的IP地址数串。简单来说就是IP的昵称，比如此网站的域名叫做harveyhust.top，还算好记，但是要是改成IP地址估计我自己都得天天查备忘录。DNS就是解析IP地址的工具，没有解析DNS的网站通过域名是无法访问的。</p><h3 id="4-数据库："><a href="#4-数据库：" class="headerlink" title="4.数据库："></a>4.数据库：</h3><h3 id="建站流程"><a href="#建站流程" class="headerlink" title="建站流程"></a>建站流程</h3><ul><li>先确定要做的是一个什么网站，就是说做这个网站是用来干什么的；<ul><li>比如说，我想做的网站是一个博客网站，那么就要围绕这些内容来进行构想，也可以参考一些同类的网站，</li></ul></li><li>根据构想好的网站主题来取一个域名，域名一定要取好；<ul><li>这个对你网站以后的发展很重要，所以一定要根据你网站的主题来取好（如果是博客网站的话，一般都会以名字全拼或者简拼来取）；</li></ul></li><li>网站程序源码<ul><li>域名取好后，接下来就是上面所说的网站建设最复杂的部分了（网页设计、程序开发）</li><li>我是自己写了一套发布系统，这种的需要有一定的技术功底和时间来细致调节，如果您没有这样的精力，建议使用开源第三方的</li></ul></li><li>服务器空间 / 主机<ul><li>待网站程序源码搞好并在本地测试正常后，根据网站要用到的空间需求来租用</li><li>一般的博客网站用 300M 的空间就足够了（以视频形式展示的博客网站除外）</li><li>还有一点需要注意的是：服务器分国内和国外，最大的区别就是国内的空间要进行备案而国外的空间不用，购买后可直接使用；</li><li>国外空间国内访问速度慢，这一点也需要注意的</li></ul></li><li>服务器空间购买好后，就将网站的程序源码用 ftp 上传工具上传到服务器空间，并将后台数据导入到空间数据库，网站就可以正常在互联网上运营了。</li></ul><h3 id="网络资源"><a href="#网络资源" class="headerlink" title="网络资源"></a>网络资源</h3><p>能以低代价却很方便的把产品或服务的信息发向全世界的每个角落。全世界所有客户都能通过 Internet 这个强有力的工具来了解博客。</p><p>Internet 已经连接了相当多的网民、企业、博客、机构和**，而且向着更广阔的范围发展。</p><p>Internet 中国正以几何级数速度发展，因此，任何一家企业 / 博客，都不应置身于 Internet 之外，那会脱离博客发展最基本的资源和环境：人类社会。数据库实际上就是一个文件集合，是一个存储数据的仓库，本质就是一个文件系统，数据库是按照特定的格式把数据存储起来，用户可以对存储的数据进行增删改查操作。存储网页加载所需的数据。 也就是说，一个网站要能正常运行，首先需要互联网的固定IP公网服务器，其次需要数据库内放好网页所需的代码文件和资源文件，再购买一个域名并用DNS解析到该服务器才能正常访问。如果服务器在国内还需要工信部和公安部备案，比如本站服务器在深圳，备案号要求放置在网站首页最底部且链接至国家工信部网站。</p><h1 id="vlan、三层交换机、网关、DNS、子网掩码、MAC地址"><a href="#vlan、三层交换机、网关、DNS、子网掩码、MAC地址" class="headerlink" title="vlan、三层交换机、网关、DNS、子网掩码、MAC地址"></a>vlan、三层交换机、网关、DNS、子网掩码、MAC地址</h1><h3 id="一、什么是-vlan"><a href="#一、什么是-vlan" class="headerlink" title="一、什么是[vlan]?"></a><strong>一、什么是[vlan]?</strong></h3><p>VLAN中文是“<a href="https://520526.xyz/tag/909">虚拟</a><a href="https://520526.xyz/tag/906">局域网</a>”。LAN可以是由少数几台家用计算机构成的<a href="https://520526.xyz/tag/465">网络</a>，也可以是数以百计的计算机构成的企业网络。VLAN所指的LAN特指使用路由器分割的网络——也就是广播域。</p><p>听上面的概念，肯定有不少朋友是一头雾水的，什么是<a href="https://520526.xyz/tag/909">虚拟</a><a href="https://520526.xyz/tag/906">局域网</a>？好好的，为什么要划分v<a href="https://520526.xyz/tag/904">lan</a>？</p><p><strong>这里举个例：通俗的了解</strong></p><p>一所高中，新学期高一招了800个<a href="https://520526.xyz/tag/908">学生</a>，这800个<a href="https://520526.xyz/tag/908">学生</a>，如果放在一个班里，那肯定是管理不过来，面对800个人，<a href="https://520526.xyz/tag/907">老师</a>看了也头疼，这边在授课，那边完全听不到，老师布置什么任务，也会有一些传达不到，老师要是想找某个学生的信息，要从800份信息中去找，极其麻烦，浪费时间；</p><p>而实际中，也是一样，<a href="https://520526.xyz/tag/905">电脑</a>A要想要与电脑B通信，于是电脑A就需要发送arp请求，而网络中电脑众多，最终ARP请求会被转发到同一网络中的所有电脑，才能找到电脑B，如此一来，为了找到电脑B，消耗了网络整体的带宽，收到广播信息的计算机还要消耗一部分CPU时间来对它进行处理。造成了网络带宽和CPU运算能力的大量无谓消耗。</p><p><strong>那么怎么办呢？</strong></p><p>学校就针对这800个学生，分成了10个班，每个班80人，分别命名为高一（1）班，高一（2）班、、、、高一（10）班，每个人都会获得一个班级编号。</p><p>1101表示一班01号学生。</p><p>1102表示一班02号学生。</p><p>1201表示2班01号学生。</p><p>同一个班的学生编号尾数不同，其它的都相同。</p><p>那么这样老师再管理起来就轻松多了，可以把一班这80人管理的妥妥的，隔壁2班与3班乱成一锅粥也不管一班的事，我就要这一班80人好好上课就行。</p><p>这就是vlan，每个班就相当于一个vlan，而每个班名称，就相当于vlan的名称，而每个学生的编号就是ip地址；同班同学（同一个vlan的ip），因为同一个教室，朝夕相处，且可以相互通信，不同班的同学，若不做其它工作，很难往来通信。</p><p>所以同一个vlan间，可以相互通信；不同vlan，若不做配置，不能相互通信。那么不同vlan如何通通信呢？就需要单臂路由与三层交换机。</p><h3 id="二、单臂路由与三层交换机"><a href="#二、单臂路由与三层交换机" class="headerlink" title="二、单臂路由与三层交换机"></a><strong>二、单臂路由与三层交换机</strong></h3><p>我们知道要实现不同vlan间通信，就必须需要有路由功能，不同VLAN之间相互通信的两种方式（单臂路由、三层交换机）。</p><h4 id="什么是单臂路由？"><a href="#什么是单臂路由？" class="headerlink" title="什么是单臂路由？"></a><strong>什么是单臂路由？</strong></h4><p>单臂路由的实现方式，其实就是普通二层交换机加路由器，从而实现不同vlan间的可以互相通信。</p><p><a href="https://img-blog.csdnimg.cn/img_convert/7ce290de2a88c72059c6772bc031a3f5.png"><img src="https://img-blog.csdnimg.cn/img_convert/7ce290de2a88c72059c6772bc031a3f5.png" alt="img"></a></p><h4 id="那什么是三层交换机呢？"><a href="#那什么是三层交换机呢？" class="headerlink" title="那什么是三层交换机呢？"></a><strong>那什么是三层交换机呢？</strong></h4><p>对于小型的网络，单臂路由可以应付，但随着VLAN之间流量的不断增加，很可能导致路由器成为整个网络的瓶颈，出现掉包、或者通信堵塞。</p><p>为了解决上述问题，三层交换机应运而生。三层交换机，本质上就是“带有路由功能的（二层）交换机”。路由属于OSI参照模型中第三层网络层的功能，因此带有第三层路由功能的交换机才被称为“三层交换机”。</p><p>关于三层交换机的内部结构，可以参照下面的简图。</p><p><a href="https://img-blog.csdnimg.cn/img_convert/22b5a8de957563bd2b681f08b0965125.png"><img src="https://img-blog.csdnimg.cn/img_convert/22b5a8de957563bd2b681f08b0965125.png" alt="img"></a></p><p>在一台本体内，分别设置了交换机模块和路由器模块；而内置的路由模块与交换模块相同，使用ASIC硬件处理路由。因此，与传统的路由器相比，可以实现高速路由。并且，路由与交换模块是汇聚链接的，由于是内部连接，可以确保相当大的带宽，所以对于正规的项目，需要使用三层交换机来实现网网络间的通信。</p><h3 id="三、什么是网关"><a href="#三、什么是网关" class="headerlink" title="三、什么是网关"></a><strong>三、什么是网关</strong></h3><p>在了解了vlan与三层交换机后，能不能通信，还需要看网关是否正确。<strong>一、什么是网关</strong></p><p>网关(Gateway)又称网间连接器、协议转换器。网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。</p><h3 id="二、如何来理解网关"><a href="#二、如何来理解网关" class="headerlink" title="二、如何来理解网关"></a><strong>二、如何来理解网关</strong></h3><p>大家都知道，从一个房间走到另一个房间，必然要经过<strong>一扇门</strong>。同样，从一个网络向另一个网络发送信息，也必须经过一道“关口”，这道关口就是网关。顾名思义，网关(Gateway)就是一个网络连接到另一个网络的“<strong>关口</strong>”。</p><p>按照不同的分类标准，网关也有很多种。TCP/IP协议里的网关是最常用的，在这里我们所讲的“网关”均指TCP/IP协议下的网关。</p><h3 id="三、网关的ip地址"><a href="#三、网关的ip地址" class="headerlink" title="三、网关的ip地址"></a><strong>三、网关的ip地址</strong></h3><p><strong>那么网关到底是什么呢？</strong></p><p>网关实质上是一个网络通向其他网络的IP地址，网关在网段内的可用<strong>ip中选一个</strong>，不过，一般用的是<strong>第1个和最后一个</strong>。</p><p><strong>例如</strong></p><p>比如有网络A和网络B，</p><p><strong>网络A：</strong>的IP地址范围为“192.168.1.1~192. 168.1.254”，子网掩255.255.255.0；</p><p>如果需要与其它网段通信，那么它的网关可以设置为192.168.1.1，当然也可以设置为<strong>网段内</strong>其它的一个ip地址。</p><p><strong>网络B：</strong>的IP地址范为“192.168.2.1~192.168.2.254”，子网掩码255.255.255.0。</p><p>如果需要与其它网段通信，那么它的网关可以设置为192.168.2.1，当然也可以设置为<strong>网段内</strong>其它的一个ip地址。</p><p><a href="https://img-blog.csdnimg.cn/img_convert/b827f022f44206252b92e1c7d633b666.png"><img src="https://img-blog.csdnimg.cn/img_convert/b827f022f44206252b92e1c7d633b666.png" alt="img"></a></p><h3 id="四、网关是如何实现通信？"><a href="#四、网关是如何实现通信？" class="headerlink" title="四、网关是如何实现通信？"></a><strong>四、网关是如何实现通信？</strong></h3><p>在没有<strong>路由器</strong>的情况下，不同的两个网络之间是<strong>不能</strong>进行TCP/IP通信的，即使是两个网络连接在同一台交换机(或集线器)上，TCP/IP协议也会根据子网掩码(255.255.255.0)判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则<strong>必须通过网关</strong>。</p><p>如果<strong>网络A</strong>中的主机发现<strong>数据包</strong>的目的主机<strong>不在</strong>本地网络中，就把数据包转发给它<strong>自己的网关</strong>，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机(如附图所示)。网络B向网络A转发数据包的过程。</p><p>所以说，只有设置好网关的<strong>IP地址</strong>，TCP/IP协议才能实现不同网络之间的相互通信。</p><h3 id="五、什么是默认网关？"><a href="#五、什么是默认网关？" class="headerlink" title="五、什么是默认网关？"></a><strong>五、什么是默认网关？</strong></h3><p>如果搞清了什么是网关，默认网关也就好理解了。就好像一个房间可以有多扇门一样，一台主机可以有多个网关。<strong>默认网关</strong>的意思是一台主机如果找不到可用的网关，就把数据包发给默认<strong>指定的网关</strong>，由这个网关来处理数据包。现在<strong>主机</strong>使用的网关，一般指的是默认网关。</p><h3 id="四、什么是DNS"><a href="#四、什么是DNS" class="headerlink" title="四、什么是DNS"></a><strong>四、什么是DNS</strong></h3><p>DNS是域名解析服务器（Domain Name System），是把网址变成IP地址的服务器。</p><p>DNS说白了是把域名翻译成IP地址用的，这里面<strong>举个例子</strong>，大家就很容易清楚了。</p><p>例如我们在浏览器里面输入<a href="http://www.baidu.com的时候,机器要跟百度这个网站进行**通信**,机器要往外面**发送**数据包,数据包里面要写百度这台服务器的**ip地址**,我们不知道ip地址是多少,那么就需要主机**问dns服务器**,dns服务器就自动帮我们把www.baidu.com这个域名**翻译成**了ip地址61.135.169.105.然后写到了数据包的目的ip地址里面就可以进行通信./">www.baidu.com的时候，机器要跟百度这个网站进行**通信**，机器要往外面**发送**数据包，数据包里面要写百度这台服务器的**IP地址**，我们不知道IP地址是多少，那么就需要主机**问DNS服务器**，DNS服务器就自动帮我们把www.baidu.com这个域名**翻译成**了IP地址61.135.169.105。然后写到了数据包的目的IP地址里面就可以进行通信。</a></p><p>就跟我们写信一样，你得写个收信人的<strong>地址</strong>邮局才能给你发送吧，你给国外写信，你写中文地址邮局不认识，需要这个一个人帮你翻译成英语。这就是DNS的作用，所以你的在本地连接里面写DNS才可以正常浏览网页，如果不设置DNS，是无法正常访问网页的。</p><h3 id="五、MAC地址"><a href="#五、MAC地址" class="headerlink" title="五、MAC地址"></a><strong>五、MAC地址</strong></h3><p>讲到MAC地址，就不得不提ip地址，这里顺便把ip地址也说下。</p><h4 id="IP与MAC"><a href="#IP与MAC" class="headerlink" title="IP与MAC"></a><strong>IP与MAC</strong></h4><p>虽然现在已经ipv6了，但我们基本用的大多数还是ipv4协议，所谓ip就是你电脑整个<strong>网络的编号</strong>。其他电脑想访问电脑就得需要这个编号。但是这个编号很多情况下是一直在<strong>变化</strong>的。唯一不变的是你的MAC地址：<strong>物理地址</strong>。</p><p>MAC是网络中用来标识网卡设备的唯一网络地址。由相关硬件制造商统一分配，每台电脑的MAC地址都是<strong>唯一</strong>的。</p><p>做个比喻，你经常搬家，你没搬一次家都有一个地址，XX小区XX单元XX号，这个就是IP。但是你的名字不变，这个就是MAC，不同的是我们的<strong>MAC不允许重名。</strong></p><p><a href="https://img-blog.csdnimg.cn/img_convert/4b27c62de27cd3d62f5ba6dd083de3eb.png"><img src="https://img-blog.csdnimg.cn/img_convert/4b27c62de27cd3d62f5ba6dd083de3eb.png" alt="img"></a></p><p><strong>我们的IP分为两个部分：如上图分为网络部分</strong>和<strong>主机部分</strong>。网络部分好比就是你在XX省XX市XX镇，这个是国家固定下来了的。但是XX小区XX单元XX号是开发商自己定的。两个编号<strong>加起来</strong>就是你的ip了。不同的是在现实中两个编号的长度是固定的，在网络上A、B、C、D的ip地址却是变化的，这个在前天有详细讲到。</p><h3 id="六、子网掩码"><a href="#六、子网掩码" class="headerlink" title="六、子网掩码"></a><strong>六、子网掩码</strong></h3><p>子网掩码是为了区分网络位和主机位，上面我们说到过，一个ip地址是由<strong>网络部分</strong>和<strong>主机部分。</strong>正如一个人的名字由姓与名组成。</p><p>那么我们可以把IP地址比作一个人的名字，那么子网掩码就像是一份名单，可以快速的知道那些人同姓，那些人不同姓，把同姓的人分在一组，让他们之前可以互相交流。</p><p><strong>举个例子</strong></p><p><strong>有一个网段</strong>是192.168.1.0-192.1.254，这个网段就像一个村子一样，就称它为<strong>安防村</strong>，此这网段有个ip地址是192.168.1.1，我们就叫他安防一，另外一个人叫安防二，它的ip地址为192.168.1.2，我们一看他们，就知道他们是同村的。</p><p><strong>另外有一个网段，是192.168.0.0——192.168.255.254，我们叫它安村</strong>，村里有个同样有两个ip地址为92.168.1.1与192.168.1.2，也叫安防一，安防二，那么问题来了？这个时候，如何区分他们是属于那个村的？</p><p>这个时候就需要<strong>子网掩码</strong>了来判断他们是属于那个网段的，需要把安防一、安防二带到村里去认下，就知道他们是属于那个村了，<strong>安防村</strong>的网段是255.255.255.0，<strong>安村</strong>的网段是255.255.0.0。</p><p>网络中也会出现类似于“同名”“同姓”的ip地址，如何区分他们到底是属于那个网段，就需要依靠子网掩码了。</p><p>这是我整理到得一些常识，可以了解了解。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
          <category> 自学网络常识 </category>
          
          <category> 网络常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站 </tag>
            
            <tag> 网络常识 </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记</title>
      <link href="posts/7b67faab.html"/>
      <url>posts/7b67faab.html</url>
      
        <content type="html"><![CDATA[<h1 id="叔本华人生的智慧读书笔记"><a href="#叔本华人生的智慧读书笔记" class="headerlink" title="叔本华人生的智慧读书笔记"></a>叔本华人生的智慧读书笔记</h1><h2 id="第一章，基本分类笔记"><a href="#第一章，基本分类笔记" class="headerlink" title="第一章，基本分类笔记"></a>第一章，基本分类笔记</h2><blockquote><p>我认为普罗大众的根本差别基于以下三项：</p><ol><li>人的自身，即广义上所讲的个性，包括健康、力量、外貌、气质、道德、智力及教育。</li><li>人的财务，即一个人拥有的财产和其他所有之物。</li><li>人的形象，可以理解为，一个人在他人眼中呈现出来的样子，实际上就是他人对他的看法和想象。这种看法又可以细分为<ul><li>名誉</li><li>地位</li><li>名声</li></ul></li></ol></blockquote><blockquote><p>幸福的源泉更多地存在于内心，而不是外身</p></blockquote><blockquote><p>与幸福直接相关的是一个人内心的快乐和痛苦，而这两种感受则是感情，欲望和思想的产物</p></blockquote><blockquote><p>同样的事物或境遇对不同的人产生的影响是大不相同的，即使所处的环境完全相同，每个人也生活在不同的世界里，因为与一个人直接相关的只有他自己的观点，感受和欲望，外在事物只有通过刺激这些方面，才能对一个人造成影响</p></blockquote><blockquote><p>因此，一个人的世界是荒芜贫瘠，无聊，浅薄，还是丰富有趣，意义非凡，都取决于他对这个世界的理解</p></blockquote><blockquote><p>所有的一切都基于同一个事实：现实世界是由主观和客观两个部分组成的。</p></blockquote><blockquote><p>尽管每个人的一生中，外在的变化始终不曾停止，但是人的个性却始终如一，这就好像是一首曲子，虽然能加的变奏很多，但主旋律却始终保持不变。</p></blockquote><blockquote><p>一个人的一生，也就是独自一人的时候陪伴着自己的，别人不能给予或拿走的那些素质，对他的重要性明显胜于任何他所拥有的财物和他在别人眼中的形象。</p></blockquote><blockquote><p>我们应当遵循自身的个性特点，为自己的个性提供相对合适的发展，除此之外的一切都尽量避免，按照这个原则，我们就必须选择与自身个性相匹配的地位，职业，和生活方式。</p></blockquote><blockquote><p>人自身拥有的东西才是获得幸福最重要的因素，因为物以类聚，人以群分。内在精神的贫乏，和空虚所造成的无聊。</p></blockquote><blockquote><p>彼得尼斯：你有多少财产，在别人眼中就有多少价值是正确的，反过来也是正确的，即他人对你良好的评价，也能以各种形式帮助你获得物质财富。</p></blockquote><h2 id="论人的自身读书笔记"><a href="#论人的自身读书笔记" class="headerlink" title="论人的自身读书笔记"></a>论人的自身读书笔记</h2><blockquote><p>一个人首先能享受到的只有发自本身的乐趣。</p></blockquote><blockquote><p>因此，获得<strong>幸福首要决定性因素</strong>是个体本身所具备的<strong>优秀</strong>品质，比如高贵的品格，出色的智力，乐观的性格，愉快的心境和健康的体魄——总结一句话就是，健康的精神寓于健康的体魄之中，这些才是我们幸福生活的首要保证，我们应当<strong>保持和提升</strong>这些品质。</p></blockquote><blockquote><p>众所周知，保持健康的手段无非是<strong>避免无节制的纵欲放荡，大起大落的情绪波动，以及持续高强度的精神紧张。</strong></p></blockquote><blockquote><p>如果不运动或极少运动，就像大部分久坐不懂得静止族，我们身体得静止状态就会和内部持续不断的运动形成极大的不协调，<strong>树木要生长的茂盛，也少不了风的吹拂。</strong></p></blockquote><blockquote><p>周遭事物给我们带来的感觉有什么不同，我们就会有答案，带给我们快乐和忧伤的，并不是现实世界中的客观事物，而是我们对这些事物的解读。</p></blockquote><blockquote><p>扰乱人们心绪的不是客观事物，而是人们对客观事物的见解。</p></blockquote><blockquote><p>健康是我们应该关注的重中之重，其他为此而付出健康的代价是最大的愚蠢</p></blockquote><blockquote><p><strong>郁闷和沮丧心情困扰的时候，这是由个体原本带有的，不可改变的机体特性所决定的，一个人的感知能力过强与身体机能出现不一致协调的情况，容易陷入情绪失控，周期性愉悦和无法自拔的忧郁中</strong></p></blockquote><blockquote><p>运动越多，生命力就越旺盛</p></blockquote><blockquote><p>美丽的外表与健康，美丽的外表与健康并不能直接给当事人幸福感，而是间接的通过留给他人美好印象的方式而获取幸福的。</p></blockquote><blockquote><p> <strong>痛苦和无聊之间是对立的，一个是外在的，客观的，另一个则是内在的，主观的。外在的客观就是穷困窘迫造成的痛苦，内在的主观就是丰衣足食带来的无聊。</strong></p></blockquote><blockquote><p><strong>内心的空虚是无聊的根源</strong></p></blockquote><blockquote><p><strong>一个人自身拥有的越多，他对外部的需求也就越少，他人对他来说就越无足轻重。</strong></p></blockquote><blockquote><p>个人的社交活动活跃程度与其精神世界匮乏的程度和平庸的程度是成正比的。</p></blockquote><blockquote><p>个体不断努力获得的闲暇是自我存在的成果，它能使个体自由的享受自我意识和自我个性，除此之外，剩下的就只有幸苦和劳作。</p></blockquote><blockquote><p>闲暇给了人支配自身的机会，而那些自身就拥有某些优秀品质的人，才能称得上幸福。</p></blockquote><blockquote><p>一个内心丰富、不需要或者很少要从外部寻求娱乐的人，无疑是最幸福的</p></blockquote><blockquote><p>我们不应该对自身以外的东西期待过高，别人的帮助非常有限，最终还是要靠我们自己，所以，最关键的是独自一人的样子</p></blockquote><blockquote><p><strong>每个人都要努力，成为最好的自己，在这一点上做的越好，就越能从自身获得更多的乐趣，当然就越幸福。</strong></p></blockquote><blockquote><p>一个人自身所拥有的东西就会比以往任何时候都重要，因为，自身所拥有的东西能留存的时间最长，不过，对于各个年龄阶段的人来说，自身拥有都是真正的，经久不衰的唯一来源。</p></blockquote><blockquote><p>如果本身缺乏精神力量，或者我们的精神力量没得到足够的历练，又或者我们欠缺一个能让精神力量付诸实践的机会，那么我们的悲苦就会非常的巨大。</p></blockquote><blockquote><p>凡是无所事事的人，都会选择一种与自身能力相匹配的游戏来消磨时间，比如打游戏，下棋，打猎，画画，赛跑，听音乐，打牌，吟诗，学哲学，做文章等等</p></blockquote><blockquote><p>人类的三个基本的生理能力，带来的活动，就是带来的快乐源泉</p><ul><li>第一种快乐是<strong>新陈代谢</strong>带来的，包括，吃喝，休息，睡觉等 普罗大众所推崇，是全民性的娱乐项目</li><li>第二种快乐是<strong>运动</strong>带来的，散步，跑步，跳舞，等</li><li>第三种快乐是<strong>感知</strong>带来的，比如观察，思考，感觉，作诗，画画，演奏音乐，学习，阅读，冥想，发明创造，思考哲学</li></ul></blockquote><blockquote><p>但我们每个人都清楚，源自于个人的能力快乐以及通过不断地重复这种乐趣而产生的幸福感就越大，那么作为前提影响和决定它们的能力就越高端</p></blockquote><blockquote><p>人区别于动物最突出的一点就是强大的感知能力，存在于认识世界的，也就是精神世界的快乐</p></blockquote><blockquote><p><strong>人之所以会变得平庸，就是因为他自身意识中欲望超过了认知，以致于认知不得不完全服从于欲望的程度。欲望和认知的这种关系所造成的后果是，人们没有一丁点动力去培养认知，大脑一片空白。</strong></p></blockquote><blockquote><p>然而事实情况是，这种缺乏认知的欲望及其普遍，在平庸的状态中，只有人的感官和处理这些感官信息所必须的微弱理解力呈现出活跃的状态，这就导致了人无时无刻不在全面的关注和接收周围瞬息而过的信息</p></blockquote><blockquote><p>具有强大精神力量的人却能够全身心的投入到培养自我认知能力的行动中去，不受到任何欲望的刺激和摆布</p></blockquote><hr><h1 id="一些感悟"><a href="#一些感悟" class="headerlink" title="一些感悟"></a>一些感悟</h1><p>我希望上天一直对我不公平，像以前那样，让我过的不如意，这样，我能更坚强。——友人赠</p><hr><p>世界上只有一种英雄主义，就是发现了生活的真相，依旧热爱它。</p><blockquote><p>最怕你一生碌碌无为，还安慰自己平凡可贵！I’m most afraid that you will not do anything in your life, and comfort yourself that you are ordinary and valuable</p></blockquote><ul><li><p><strong>人们倾向于记住最先发生的事情和最后发生的事情。</strong> 中间的事情记不清楚。所以，如果你要做自我介绍的话，最好做第一个或者最后一个。面试的时候，也是一样的。</p></li><li><p><strong>如果你在酒吧或者前台工作，在你身后放一面镜子。</strong> 这样的话，当顾客发脾气的时候，就能从镜子里看到自己的丑恶嘴脸。一面镜子可以显著降低他们无理取闹的概率。</p></li><li><p><strong>报价之后，不再说话。</strong> 如果你是做销售工作的，这项技巧很有用。在其他领域，这项技巧也很有用。我之前干过一份工作，是在一家体育馆卖会员卡。有个老家伙就是这么指导我的，他说，一旦你和顾客寒暄完毕，报出了你的价格。从此时开始，先开口的那个就输了。看起来好像毫无根据，但确实是这个样子的。通常会有很长时间的尴尬沉默，但是，最终，顾客会买的。</p></li><li><p><strong>如果你问了别人一个问题，然后他们回答了一半，你等着，他们会说完的。</strong>只要等着，保持眼神接触，最终，他们会开口讲完的。</p></li><li><p><strong>公开讲话或者蹦极之前这种会紧张的时刻，嚼口香糖就好了。</strong> 据说是因为人类在危险的时候会自动停止咀嚼（吃东西），所以吃东西的时候就是安全的，大脑就是这么告诉你的。反正这招对我很管用。</p></li><li><p><strong>人们最终记住的不是你说过的话，而是你让他们产生的感觉。</strong> 几乎所有的人都喜欢谈论自己的事情，所以，多问问题。</p></li><li><p><strong>当你学习新东西的时候，尝试着教给朋友们，或者让他们问你相关的问题。</strong> 如果你能教给人一杯水，你自己一定会有一桶水。</p></li><li><p>** 如果你看到某人时，很开心，溢于言表的开心，那么他们以后看到你也会手舞足蹈的。** 第一次也许不是这样，但第二次一定是。</p></li><li><p><strong>身体对压力的反应——呼吸加速，心跳加快——和鼓起勇气时的反应是一样的。</strong>所以是好是歹，全在你一念之间。反正你的身体已经都准备好了，你看着办吧。</p></li><li><p><strong>注意别人的脚。</strong>当你加入别人的谈话时，发现别人只是把上半身转过来了，脚还是维持原来的方向，那就说明他们不欢迎你的加入。类似的，你和你的同事谈话时，你觉得他在专心和你谈话，他的身体也面向你，但他的脚却不是朝向你的，他可能早就已经受不了这场谈话了。</p></li><li><p><strong>装出牛逼的样子，直到你做到了；信心比知道更重要。</strong>别被任何人吓住，生活不易，全靠演技，那些吓你的人也在演戏。</p></li><li><p><strong>你假装成什么样子，你最终就会成为什么样子。</strong> 装逼得逼，求仁成仁，念念不忘，必有回响。</p></li><li><p><strong>虽然不是要你去吓人，但如果你一定要厚颜无耻的盯着某人，视线聚集在他的两只眼睛中间，等着他们害羞。</strong> 如果他们移开视线，他们就不会再看着你。这个时候，你就可以肆无忌惮的盯着他们的眼睛了。至少有45秒的时间哦。</p></li><li><p><strong>建立人际网络。</strong>成为朋友们的信息源，当然，他们也会是你的信息源。和前同事一起喝杯酒吧，也是好的。</p></li><li><p><strong>如果你前面的车子慢的像是老爷爷在开，你恨不得杀了他。</strong> 假装他真的是你的亲爷爷。 然后你的怒气就全消了。</p></li><li><p><strong>站得直。</strong> 不许没精打采，不许手插兜，头要高高抬起。不要觉得这是陈词滥调。你自己会因此觉得很好，而且周围的人也会感受到你的自信。</p></li><li><p><strong>不要说“我觉得”、“我认为”，除非真的有必要。</strong>这些词语会让你和自信无缘，对你可没什么好处。</p></li><li><p><strong>焦虑的时候，收拾一下家里或者工作桌。</strong> 你会比之前更开心、更有感觉。</p></li><li><p><strong>第一次饭，第一支酒，你请。</strong>你都不知道你自己会因此而自我感觉良好多久。</p></li><li><p><strong>为人父母者请注意：给孩子们选择的权利，让他们认为自己掌控自己的生活。</strong> 比如我想让孩子自己穿鞋的时候，我会问他“你是想穿那双星星的，还是鲨鱼的？”。值得注意的是，这招对成年人也管用。</p></li><li><p><strong>态度决定行动，可是行动也决定态度。</strong> 就像我以前的一个老师说的那样：你可以因为高兴而跳起舞来，也可以故意跳起舞来让自己高兴。</p></li><li><p><strong>一群人在大笑的时候，人们会立刻看向这群人里最亲近的人。</strong></p></li><li><p><strong>如果你想和某人建立密切的关系，或者获得某人的信任，学习他的身体的姿势。</strong> 如果他翘起二郎腿，你也翘起来。如果他斜靠在椅背上，你也斜靠在椅背上，如果他身体前倾，你也身体前倾。模仿身体姿势，是一种下意识的信任对方和自在的表现。如果你在胸前交叉双臂时发现某人随即也这么做了，恭喜你，你又迷住了一个人。</p></li><li><p><strong>本杰明·富兰克林效应。</strong>在学生时代，找女生借铅笔、借笔记、求她帮你补习功课，比起借给她东西、帮她补习功课，女生更容易爱上找她借铅笔的那个穷/笨小子。调情的时候这也很有用，比如（开玩笑似的）让女孩请你喝支酒。这可是一石三鸟的事情：你得到了好处；她会下意识的更喜欢你；将来她接受你的“帮助”也会更加没有负担。</p></li></ul><blockquote><p>理想的自己</p><p>洋葱、萝卜和西红柿不相信世界上有南瓜这种东西， 它们认为那是一种空想。 南瓜不说话， 默默地生长。 ——于尔克•舒比格</p><p>人的一生， 其实就是一场自己对自己的战争。 每个人的身上，都有两个自己： 好的自己和坏的自己。让积极打败消极，让高尚打败鄙陋，让真诚打败虚伪，让宽容打败计较，让快乐打败忧郁，让勤奋打败懒惰，让坚强打败脆弱。 只要你愿意，完全可以一辈子都做最好的自己。</p></blockquote><blockquote><p>岁月不居 时节如流</p><p>正因为当初对未来做了太多的憧憬，所以对现在的自己尤其失望。生命中曾经有过的所有灿烂，终究都需要用寂寞来偿还。 —— ——加西亚·马尔克斯</p></blockquote><blockquote><p><strong>每一个人都有很多直觉（instinct），而直觉有许多是需要修正的。换句话说，如果你随时能够接受修正直觉的话，就继续在向前进。直觉与书本知识冲突是最好的学习机会，必须抓住这个机会。每个人都有一些直觉，没有直觉是不能生存的，但直觉往往不够准确，需要被思考、修正，形成正确的直觉，直觉重要，可是也是需要接受修正，如果你随时能够接受修正你的直觉的话，你就能继续的向前进了</strong>——这个是我一生得到的非常重要的教训。</p></blockquote><p><img src="https://pic2.zhimg.com/50/v2-9f2f7d7e31957f99f6fff746ee7c5174_hd.jpg?source=1940ef5c" alt="img"></p><p>有趣的是100年前，王国维在他的《人间词话》中写到的境界论，非常有意思。<br>他说古今之成大事业、大学问者，必经过三种境界：</p><blockquote><ol><li>昨夜西风凋碧树，独上高楼，望尽天涯路，此第一境；</li><li>衣带渐宽终不悔，为伊消得人憔悴，此第二境；</li><li>众里寻他千百度，蓦然回首，那人正在灯火阑珊处，此第三境。</li></ol></blockquote><p>大家对这境界论的解释多多少少都是统一解释。</p><ul><li>第一境界说的是对于想要追求的事情要有点<strong>执着</strong>，所以要独上高楼，去追寻你所要看见的天涯路。说的就是 <strong>兴趣</strong>。</li><li>第二境是什么意思呢？就是说即使人变得消瘦了也不要后悔，还要继续下去，要<strong>努力</strong>地准备；</li><li>第三境中，<strong>在不经意间，一回头，忽然发现秘诀在哪里，</strong>就是机遇带来的突破。</li><li>我认为这就是代表兴趣、准备、突破的三步曲，不仅在科学领域里是一个好的道路，在文学里同样是这条重要的路径。</li></ul><blockquote><p>没有在深夜痛哭过的人不足以谈人生</p></blockquote><p>奈何物以类聚，人以群分</p><p>每次都想拥抱你，</p><p>可我一无所有。</p><blockquote><h1 id="医不自医，人不渡己"><a href="#医不自医，人不渡己" class="headerlink" title="医不自医，人不渡己"></a>医不自医，人不渡己</h1></blockquote><blockquote><p>在世间，有些事只能独自去面对，有些路只能一个人去跋涉。</p><p>路再长再远，夜再黑再暗，也得独自默默走下去。</p><p>毕竟总有某段路，只能你一个人走。有些事，需要你一个人扛。<br>与其凑合绝望的生活，不如放松一点，在一个人的日子里选择自己喜欢的生活方式。</p></blockquote><blockquote><h3 id="“一个人寂然独立是完全不同的一种状态，因为内心有活跃的能量和深刻的美感。那些拥有独立人格的人，懂得照顾自己也懂得如何享受更好的生活。”"><a href="#“一个人寂然独立是完全不同的一种状态，因为内心有活跃的能量和深刻的美感。那些拥有独立人格的人，懂得照顾自己也懂得如何享受更好的生活。”" class="headerlink" title="“一个人寂然独立是完全不同的一种状态，因为内心有活跃的能量和深刻的美感。那些拥有独立人格的人，懂得照顾自己也懂得如何享受更好的生活。”"></a>“一个人寂然独立是完全不同的一种状态，因为内心有活跃的能量和深刻的美感。那些拥有独立人格的人，懂得照顾自己也懂得如何享受更好的生活。”</h3><p>在这繁杂喧嚣的世上，一个人能安静享受生活中的宁静与美好，潜下心来和自己认真对话，清楚明白自己想要什么，不随波逐流放任自己。</p><p>即使身边没有随时可以依靠倾诉的好友，也不会为了依赖而随意结交。</p><p>所以，大多单身的人，宁愿一个人寂然独立的生活，做自己的盖世英雄，也不随意将就敷衍了事。</p><p>很多人都觉得，一个人在陌生的城市太过孤独，有人陪伴就不会那么凄凉。</p><p>遇见对的人固然美好，可多数人只是为了避免孤独敷衍自己，那种触及不到内心的陪伴，最后都是相互折磨。</p><p>其实啊，人这一生总是在不断的相识和分别中度过，如果没有遇见合适的人，那就不要勉强自己。</p><h3 id="你来，我热情相拥。你走，我坦然放手。人生随缘不强留。"><a href="#你来，我热情相拥。你走，我坦然放手。人生随缘不强留。" class="headerlink" title="你来，我热情相拥。你走，我坦然放手。人生随缘不强留。"></a>你来，我热情相拥。你走，我坦然放手。人生随缘不强留。</h3><p>不求人好感</p><p>不予己难堪</p><p>一个人的生活真的没有那么可怕，要学会喜欢每一个追逐自我的时刻，用自己喜欢的方式肆意活出属于自己的幸福：</p><h3 id="随时来一场说走就走的旅行，不需要迁就另一个人改变规划；"><a href="#随时来一场说走就走的旅行，不需要迁就另一个人改变规划；" class="headerlink" title="随时来一场说走就走的旅行，不需要迁就另一个人改变规划；"></a>随时来一场说走就走的旅行，不需要迁就另一个人改变规划；</h3><h3 id="可以纵情挥霍自己的时光，不必操心对方的一日三餐；"><a href="#可以纵情挥霍自己的时光，不必操心对方的一日三餐；" class="headerlink" title="可以纵情挥霍自己的时光，不必操心对方的一日三餐；"></a>可以纵情挥霍自己的时光，不必操心对方的一日三餐；</h3><h3 id="肆意放纵自己的情绪，想哭就哭想笑就笑，不会因为对方的喜怒，失去自我……"><a href="#肆意放纵自己的情绪，想哭就哭想笑就笑，不会因为对方的喜怒，失去自我……" class="headerlink" title="肆意放纵自己的情绪，想哭就哭想笑就笑，不会因为对方的喜怒，失去自我……"></a>肆意放纵自己的情绪，想哭就哭想笑就笑，不会因为对方的喜怒，失去自我……</h3></blockquote><h2 id="人-从-众"><a href="#人-从-众" class="headerlink" title="人   从  众"></a>人   从  众</h2><blockquote><p>Life is always unexpected.</p><p>第一个阶段：</p><p>无人与我立黄昏，无人问我粥可温。</p><p>无人与我捻熄灯，无人共我书半生。</p><p>无人陪我夜已深，无人与我把酒分。</p><p>无人拭我相思泪，无人梦我与前尘。</p><p>无人陪我顾星辰，无人醒我茶已冷。</p><p>无人听我述衷肠，无人解我心头梦。</p><p>无人拘我言中泪，无人愁我独行路。</p><p>回首向来萧瑟处，无人等在灯火阑珊处。</p></blockquote><blockquote><p>第二个阶段：</p><p>残阳与我立黄昏，阿婆问我粥可温。</p><p>飞蛾与我捻熄灯，笔砚共我书半生。</p><p>孤月陪我夜已深，往事与我把酒分。</p><p>春风拭我相思泪，睡梦与我恋前尘。</p><p>微风陪我顾星辰，案几知我茶已冷。</p><p>归燕听我诉衷肠，暗香解我心头梦。</p><p>素衣拘我言中泪，竹杖伴我独行路。</p><p>回首向来萧瑟处，那人却在灯火阑珊处。</p></blockquote><blockquote><p>第三个阶段：</p><p>愿与执手立黄昏，愿与品茗粥尚温。</p><p>愿与添香捻熄灯，愿与捧卷书半生。</p><p>愿与剪烛夜已深，愿与对弈把酒分。</p><p>愿与叠袖相拭泪，愿与入梦共前尘。</p><p>愿与赏月顾星辰，愿与烹茶清未冷。</p><p>愿与静听诉衷肠，愿与话君心头梦。</p><p>愿与解语心中泪，愿与共行天下路。</p><p>回首灯火阑珊处，那人一如初见立中宵。</p><p>愿大家早日找到那个共同打拼互相取暖的人</p></blockquote><h1 id="夜晚独处的时候，偶尔也会胡思乱想"><a href="#夜晚独处的时候，偶尔也会胡思乱想" class="headerlink" title="夜晚独处的时候，偶尔也会胡思乱想"></a>夜晚独处的时候，偶尔也会胡思乱想</h1><h2 id="记录一下看到的那些触动心灵的文字"><a href="#记录一下看到的那些触动心灵的文字" class="headerlink" title="记录一下看到的那些触动心灵的文字"></a>记录一下看到的那些触动心灵的文字</h2><blockquote><p>每个人小时候都有个齐天大圣的梦，熟不知长大后，来来去去有太多害怕犹豫，走走留留有太多断断续续，真真假假有太多生死相许，是是非非又有太多欲留还拒……，最后只能在心里怀念着大圣，等待着大圣某一天归来，日子就渐渐的过成了沙僧的模样</p></blockquote><blockquote><p>现代人的崩溃，是一种默不作声的崩溃。<br>看起来很正常，会说笑，会打闹，会社交，表面平静，实际上心里的糟心事，已经积累到一定程度了。<br>不会摔门、砸东西，不会流眼泪，或歇斯底里。<br>但可能，某一秒就积累到极致了，也不说话，也不真的崩溃。<br>也不太想活，也不敢去死。<br>在什么事都喜欢诉诸简单粗暴的今天，试图让别人理解，比买爱马仕还要奢侈。<br>你在荒原上日复一日地跋涉，身后却听到各种声音，催你再走快些。<br>只有你自己知道，你缺水，你渴了，你想休息。</p></blockquote><blockquote><p>人生，就是要懂得放大别人的优点， 欣赏别人的长处， 才能相互协作， 相互支持， 价值共赢！</p></blockquote><blockquote><p>学历代表过去，能力代表现在，学习力代表未来。<br>不怕你不会，就怕你不学，了解不会带来损失，错过也许遗憾终生。</p></blockquote><blockquote><p>我失去了你，却收获了更好的自己。</p></blockquote><blockquote><p>不求人好感,不予人难堪</p></blockquote><blockquote><p>这世界上多的是不缺钱还努力工作的人，多的是身材很棒每天还坚持跑步的人，多的是长得好看还努力学习才华横溢的人，不要仅凭几分姿色洋洋得意，好看的人太多了，所谓的白富美高富帅，洁身自好为白，经济独立为富，内外兼修为美，你要有自己的思想和个性，一生努力成为更好的自己，加油陌生人！</p></blockquote><blockquote><p>与凤凰同飞，必是俊鸟；<br>与虎狼同行，必是猛兽：<br>你能走多远，看你与谁同行；<br>人抬人抬出伟人，<br>僧抬僧抬出高僧！<br>你把身边的人都看成宝， 你被宝包围着， 你就是“聚宝盆”。<br>你把身边的人都看成草，你被草包围着，你就是草包。</p></blockquote><blockquote><p>穷人富了变着法子再踩穷人，富人富了想着是如何帮助很多人更富。<br>穷与富的区别不在于钱财，而是眼界与格局，思维和心态。<br>交人交品格，德行和能力，而非权力，金钱和物质，前者会患难与共，后者会利尽则散。</p></blockquote><blockquote><p>可人生就是如此，年轻的时候什么都很贵，爱情最廉价。等到你觉得什么奢侈品都不奢侈的时候，爱情就变成了最奢侈的玩意。</p></blockquote><blockquote><p>一个人一生所能达到的高度，源于他年轻时思想的深度</p></blockquote><blockquote><p>老师问：什么是天使，什么是魔鬼？<br>所有同学都默不作声，<br>但有一位同学回答说：<br>天使就是能为整个世界负你，<br>而魔鬼是能为你负整个世界。<br>好精辟的一段话，所以我也在问我自己是要天使还是要魔鬼？</p></blockquote><blockquote><h1 id="主题-学会生活"><a href="#主题-学会生活" class="headerlink" title="主题-学会生活"></a>主题-学会生活</h1><ol><li>有时候，人所需要的是真正的绝望。真正的绝望跟痛苦、悲伤没有什么关系。它让人心平气和，让你意识到你不能依靠别人，任何人，得到快乐。它让你谦卑，因为所有别人能带给你的，都成了惊喜。</li><li>如果我们不想对人或事失望，惟一的方法就是不要对它寄予任何希望。这不是绝望，这是生存下去的有效途径，亦是获取幸福感的前提。”</li><li>没有一点儿疯狂，生活就不值得过。听凭内心的呼声的引导吧，为什么要把我们的每一个行动像一块饼似的在理智的煎锅上翻来覆去地煎呢？</li><li>你一直在练习微笑，倒不是说变成了自己讨厌的人，而是在世故中变得沉稳，总不能累了就放弃，痛了就喊疼。相信别人不如依赖自己，他人报以伤害，时光会给你温暖。</li><li>你的脸上云淡风轻，谁也不知道你的牙咬得有多紧。你走路带着风，谁也不知道你膝盖上仍有曾摔伤的淤青。你笑得没心没肺，没人知道你哭起来只能无声落泪。要让人觉得毫不费力，只能背后极其努力。人，要么庸俗，要么孤独！”</li></ol></blockquote><blockquote><ol><li>不管全世界所有人怎么说，我都认为自己的感受才是正确的。无论别人怎么看，我绝不打乱自己的节奏。喜欢的事自然可以坚持，不喜欢怎么也长久不了。”</li><li>每个年龄，都有每个年龄相匹配的烦恼。无一例外。每个年龄的烦恼，都会在那个年龄的地方，安静地等着你，从不缺席。”</li><li>走到生命的哪一个阶段，都该喜欢那一段时光，完成那一阶段该完成的职责，顺生而行，不沉迷过去，不狂热地期待着未来，生命这样就好。不管正经历着怎样的挣扎与挑战，或许我们都只有一个选择：虽然痛苦，却依然要快乐，并相信未来。”</li><li>当一颗树不再炫耀自己叶繁枝茂，而是深深扎根泥土时，它才真正的拥有深度。当一颗树不再攀比自己与天空的距离，而是强大自己的内径时，它才真正的拥有高度。树的成长需要深度和高度，人亦如此。</li></ol><h3 id="你最可爱，我说时来不及思索，但思索之后，还是这样说。"><a href="#你最可爱，我说时来不及思索，但思索之后，还是这样说。" class="headerlink" title="你最可爱，我说时来不及思索，但思索之后，还是这样说。"></a>你最可爱，我说时来不及思索，但思索之后，还是这样说。</h3><ol><li>破例说个秘密。其实我不用看到你的脸才能喜欢你，也不用听到你的声音，不用知道你有什么消息。我所知道的是，在生活中不多见的闪光的时刻我会想到你，烟花升起来，雪落下去，人们围上来拥抱我，这样的时刻。我猜你和世界上所有的美好连在一起。所以我想尽量去看一些好的东西，这就是我喜欢你的方式。”</li><li>问：“想跟一个人结婚的心情是怎样的？”<br>答：“一辈子面对一个人 想想就可怕 但如果是眼前这个人的话 愿意赌一下”</li><li>一想到余生将和你一起度过，我就对余生充满了期待</li><li>为什么要谈恋爱？是酒不好喝呢？还是游戏不好玩呢~单身多爽，哈哈哈</li><li>在一个人逐渐成熟之际，为何只能变得更加谨慎呢？我想是由于害怕失败的缘故；我总是容易忘记我的收获，却只记得所有失去的。挫折堆叠得很高，它摧毁了我全部的信心，直到我长大成人后再也没勇气尝试冒险。我用前半生努力让自己变成一个成年人，也许后半生该学习如何做个小孩。”</li></ol></blockquote><blockquote><h2 id="曾经的你"><a href="#曾经的你" class="headerlink" title="曾经的你"></a>曾经的你</h2><p>像我这样的人，是不太喜欢结识新朋友的。</p><p>你知道，介绍自己的过去很累的。</p><p>可遇见你那天，</p><p>我竟想着要把我的前半生拍成电影给你看，</p><p>让你看看我见过的呼伦贝尔的雪，</p><p>我走过的四下无人的街，</p><p>和我度过的烂醉如泥的夜，</p><p>把所有你未能参与的人生补齐。</p><p>然后呢，跟我走吧。</p><p>纵此生不见，</p><p>平安惟愿，</p><p>若得闲，</p><p>仍念，</p><p>歉。</p></blockquote><blockquote><p>第一最好不相见，如此便可不相恋。</p><p>第二最好不相知，如此便可不相思。</p><p>第三最好不相伴，如此便可不相欠。</p><p>第四最好不相惜，如此便可不相忆。</p><p>第五最好不相爱，如此便可不相弃。</p><p>第六最好不相对，如此便可不相会。</p><p>第七最好不相误，如此便可不相负。</p><p>第八最好不相许，如此便可不相续。</p><p>第九最好不相依，如此便可不相偎。</p><p>第十最好不相遇，如此便可不相聚。</p><p>但曾相见便相知，相见何如不见时。</p><p>安得与君相诀绝，免教生死作相思。</p><p>我还是很喜欢你，像雨从天坠七万米，不惧成泥。</p><p>我还是很喜欢你，像千里戎马走单骑，八方为敌</p><p>我还是很喜欢你，像十里的春风，都不及你。</p><p>我还是很喜欢你，像风缠绕在耳畔的低语，心动不已。</p><p>我还是很喜欢你，像盛装等候一场十年的假期，情不知所以。</p><p>我还是很喜欢你，哪怕此生，后会无期。</p><p>我还是很喜欢你，像自导自演独角戏，茕茕孑立。</p><p>我还是很喜欢你，像春潮带雨晚来急，一倾千里。</p><p>我还是很喜欢你，像旧时月色花满地，悄无声息。</p><p>我还是很喜欢你，像远笛萧瑟秋风里，可有人会意？</p><p>我还是很喜欢你，春来冬往，绿了芭蕉，红了樱桃，一腔孤勇，遥遥无期。</p></blockquote><blockquote><p> 每个年龄，都有每个年龄相匹配的烦恼。无一例外。每个年龄的烦恼，都会在那个年龄的地方，安静地等着你，从不缺席。<br>  走到生命的哪一个阶段，都该喜欢那一段时光，完成那一阶段该完成的职责，顺生而行，不沉迷过去，不狂热地期待着未来，生命这样就好。<br>  不管正经历着怎样的挣扎与挑战，或许我们都只有一个选择：虽然痛苦，却依然要快乐，并相信未来。<br>  因为未来，已来</p></blockquote><blockquote><h2 id="愿你我都不只是活着一副躯壳"><a href="#愿你我都不只是活着一副躯壳" class="headerlink" title="愿你我都不只是活着一副躯壳"></a>愿你我都不只是活着一副躯壳</h2><ol><li>哈佛有一个著名的理论：人的差别来源于学习，经常抽出时间用来阅读、学习、思考，你会发现，你的人生会发生改变，成功会向你招手。</li><li>无论你的收入是多少，记得分成五份进行规划投资：增加对身体的投资，让身体始终好用；增加对学习的投资，加强你的自信；增加对旅游的投资，扩大你的见闻；增加对未来的投资，增加你的收益。好好规划落实，你会发现你的人生逐步会有大量盈余。</li><li>过去的一页，能不翻就不要翻，翻落了灰尘会迷了双眼。有些人说不出哪里好，但就是谁都替代不了! 那些以前说着永不分离的人，早已经散落在天涯了。收拾起心情，开心走下去吧。</li><li>被人误解的时候微微一笑，这是一种素养；受委屈的时候坦然一笑，这是一种大度；吃亏的时候开心一笑，这是一种豁达；无奈的时候达观一笑，这是一种境界；危难的时候泰然一笑，这是一种大气；被轻蔑的时候平静一笑，这是一种自信；失意的时候轻轻一笑，这是一种洒脱。</li><li>人生途中，有些是无法逃避的，比如命运；有些是无法更改的，比如情缘；有些是难以磨灭的……与其被动地承受，不如勇敢地面对；与其软弱自卑，不如努力奋斗……路越艰，阻越大，险越多，勇敢走过去，你的人生就会更精彩。</li><li>你改变不了环境，但可以改变自己；你改变不了过去，但可以改变现在；你不能控制他人，但可以掌握自己；你不能预知明天，但可以把握今天；你不能延伸生命的长度，但你可以决定生命的宽度。</li><li>怎么做一个积极快乐的人：要善于发现美，要养成看书的习惯，多交往优秀的朋友，培养健康的心态和身体，学会投资理财经营，学会感恩懂得珍惜。</li><li>生活里的每一个细节都蕴藏着快乐，只是在于你是否感受到了而已。让自己的快乐扩张，鼓舞和影响周围的人。</li><li>【给自己的几句温馨的话】1.每天都要开开心心 2.别总跟自己过不去 3.用心做该做的事 4.别太计较别人评价 5.有自己的活法，不必讨好别人</li><li>之所以会累，是常常徘徊在坚持和放弃之间，举棋不定。<br>之所以会烦恼，是记性太好，该记的不该记的都留在记忆里。<br>之所以不快乐，是计较的太多，追求上进太少。</li><li>男人吸引女人的十个特点:真实，诚信，胸怀，自信，风度，智慧，幽默，进取，浪漫 ，冒险.女人吸引男人的十个特点:温柔，知性，善良，涵养，勤快，漂亮，皮肤，性感，着装，香味</li><li>真正的爱，不是忍受，是支持；真正的爱，要道谢也要道歉，要体贴也要体谅，要认错也要改错。</li><li>有些人，你看见他整天都开心，率真得像个小孩，人人都羡慕他。其实，他就像向日葵，向着太阳的正面永远明媚，在照不到的背面将悲伤深藏。</li><li>如果真心爱一个人，不承诺也会去爱；如果不爱一个人，承诺也会背叛。</li><li>【你最后悔什么】某杂志对老人抽样调查：第一名：85％的人后悔年轻时努力不够，导致事业无成。第二名：75％的人后悔第一次选错了恋爱对象。第三名：70％的人后悔没有善待自己的身体。</li><li>【做人要注意的】⒈凡事留余地留退路 2.话不说绝，口无遮拦难成事 3.成熟而不世故 4.心态好，想得开，活得不累 5.没事不惹事，来事不怕事 6.放下面子做人</li><li>不要太在意一些人，太在乎一些事，不要喜欢听甜言蜜语，要珍惜真心对你好，真心帮助你的人。</li><li>一个人的成就，不是以金钱衡量，而是你善待过多少人。</li><li>发怒，是用别人的错误惩罚自己；烦恼，是用自己的过失折磨自己；<br>后悔，是用无奈的往事摧残自己；忧虑，是用虚拟的风险惊吓自己；<br>孤独，是用自制的牢房禁锢自己；自卑，是用别人的长处抵毁自己。<br>摒弃这些，你就会轻松许多！</li><li>【受益一生的好习惯】：不轻易剥夺别人的希望；不指望生活会是完全公平的；生气的时候不要作出什么决定；尽量多存钱；及时改正自己的错误；用你希望别人对待你的方式去对待别人，做什么事都尽量提前准备好。</li><li>【十种无能为力的事】：倒向你的墙、离你而去的人、流逝的青春、没有选择的出身、莫名其妙的孤独、无可奈何的遗忘、永远的过去、别人的嘲笑、不可避免的死亡、不可救药的喜欢。</li><li>爱，绝不是缺了就找，更不是累了就换。找一个能一起承担的，能对你负责的。爱不是一个人的事，而是两个人的奋斗，两个人的共同创造。</li><li>当你戴久了面具，摘下面具时发现，你的脸早就跟面具一样了。</li><li>对自己好点，对爱你的人好点，做事对得起良心。</li><li>有一种借口叫年轻，可以不珍惜时光，不珍惜爱。有一种感情叫错过，错过可以相守的人，错过一段刻骨铭心的情。有一种寂寞叫想念，想念一个人，一段美好的往事。</li><li>有些心事能讲给朋友，有些痛苦只能默默承受，自己还是要靠自己拯救。</li><li>我们都不是完美的人，要接受不完美。在孤独的时候，给自己安慰；在寂寞的时候，给自己温暖。对软弱说再见，对自己有信心，知道自己的价值。</li><li>每个人这辈子，都有过一个特别的朋友，他对你最好，和他可以无话不谈。这种友谊不低于爱情，这样的关系就是情人或者知已。</li><li>想活得开心，请放下这7样：烦恼、自卑、懒惰、消极、抱怨、犹豫、狭隘。</li><li>有三种东西必须培养：理性、谦让和好学<br>有三种东西必须控制：情绪、脾气和行为<br>有三种东西必须思考：生命、死亡和永恒<br>有三种东西必须摒弃：罪恶、贪婪和背叛<br>有三种东西必须挽救：圣洁、和平和快乐<br>有三种东西必须尊敬：坚毅、自尊和仁慈。</li><li>人生就是一列开往坟墓的列车，路途上会有很多站，很难有人可以至始至终陪着走完，当陪你的人要下车时，即使不舍，也该心存感激，然后挥手道别。</li><li>做一个坚强的人，坦然面对，勇敢体会，酸甜苦辣，各种滋味。与其沉溺过往，不如沐浴晴朗，扔掉悲伤和孤寂，不再害怕迷茫。</li><li>【写给自己的5句话】：再难也要坚持，再好也要淡泊，再差也要自信，再多也要节省，再冷也要热情。</li><li>【学会给自己提醒】:做什么事情，要换位思考，收敛自己的脾气，冲动会做下让自己无法挽回的事情，注意提高自己的修养，加倍回报真心帮你的人!</li><li>对过去恋恋不舍的人，成就不了未来。过去的种种，对现在的你已毫无意义，看好前面的路，积极前进吧。</li><li>【微博经典语录】心灵有家生命才有路、漂泊不等于自由、创伤是成熟的捷径、漂泊不定的灵魂最需要热量、人在孤独时最能找到真实的自己、人生没有如果，只有后果和结果。</li><li>【一生中不可错过的八种贵人】：愿意无条件力挺你的人、愿意唠叨你的人、愿意和你分担分享的人、愿意欣赏你的长处的人、愿遵守承诺的人、愿意不放弃而相信你的人、愿意生你气的人、愿意为你吃苦的人。你遇见了几种？</li><li>着急不过人等人，温暖不过人帮人，感动不过人疼人，残酷不过人害人，阴险不过人算人，郁闷不过人气人，耻辱不过人戏人，为难不过人求人，生气不过人比人，和谐不过人让人，幸福不过人爱人！</li><li>【16条处世秘笈】1.实干但不蛮干2.果断但不独断3.大胆但不大意4.理智但不弱智5.敢言但不妄言6.信心但不贪心7.守信但不守旧8.个性但不任性9.坦荡但不放荡10.理想但不空想11.浪漫但不散漫12.平凡但不平庸13.风趣但不风骚14.谦让但不迁就15.虚心但不虚荣16.顽强但不顽固。</li></ol></blockquote><blockquote><p>人最舒服的时刻往往并不是欲望被满足的时刻，也不是久经坎坷后的功成名就，而是波澜不惊平常的点滴充实而又温暖的那一瞬间。舒服的时刻还有太多太多，有体会青春同学情、懵懂爱情、温暖亲情、永恒友情、静谧独处的种种瞬间，我们没有办法分清楚哪个是最舒服，因为每个都对我们那么重要。</p></blockquote><blockquote><p>人生的路上，新的美好的事物像彩蛋一样，在路上我们惊喜连连。我想做的是，珍藏这些舒服的时刻在心里，我的人生多么美妙！因为这些时刻，我要像品最好的红酒一样，用心感受每个时刻，回香隽久，且且珍惜。</p></blockquote><blockquote><p><strong>那些遗忘我的人，足以建起一座城市。</strong></p><p><strong>那些我遗忘的人，却连马桶都坐不满。</strong></p></blockquote><blockquote><p>好了，我现在接受全部的失败。</p></blockquote><blockquote><p>只要你肯联系我，再勇敢一次，重蹈覆辙也无妨。你若不联系我，那就顺其自然，实不相瞒，特别想你，但能克制。</p></blockquote><blockquote><p>Man proposes,god disposes</p><p>谋事在人，成事在天</p></blockquote><blockquote><p>今夜，为你执笔，却是词穷意长，千言万语，随这月色，洒满浩渺的夜空，<br>星光璀璨，点亮彼此的灵犀，一枚素笔，万千柔情，<br>起笔是问候，落笔是思念。</p></blockquote><blockquote><p>没有很高的情商<br>没有圆滑的处世<br>遇到挫折就会抱怨<br>可我待人真诚 明辨是非<br>懂得感恩 问心无愧 </p></blockquote><blockquote><p>你不能一直做一些烂事,然后自己后悔,好像后悔有用一样,你需要变好.</p></blockquote><blockquote><p> 纵使黑夜吞噬了一切，太阳还可以重新回来</p></blockquote><blockquote><p>天空没有痕迹，风雨已在心中</p></blockquote><blockquote><p>人生的四大境界</p><ul><li>不知道自己不知道，愚昧的巅峰</li><li>知道自己不知道，有兴趣去学</li><li>知道自己知道，基本上大佬</li><li>不知道自己知道</li></ul></blockquote><blockquote><p>情绪在蓝色中溶解</p></blockquote><blockquote><p>我所有的自负皆来自我的自卑，所有的英雄气概都来自于我的软弱。嘴里振振有词是因为心里满是怀疑，深情是因为痛恨自己无情。这世界没有一件事是虚空而生的，站在光里，背后就会有阴影，这深夜里一片静默，是因为你没有听见声音。</p></blockquote><blockquote><p>我没有很刻意的去想念你， 因为我知道，遇到了就应该感恩， 路过了就需要释怀。 我只是在很多很多的小瞬间，想起你。 比如一部电影，一首歌，一句歌词， 一条马路和无数个闭上眼睛的瞬间。</p></blockquote><blockquote><p>原来爱意太明显 会把人推得更远</p></blockquote><blockquote><p>你眼中有春与秋胜过一切我见过爱过的山川与河流</p></blockquote><blockquote><p>我早就知道会失去你，却仍然选择喜欢你。</p></blockquote><blockquote><p>枯萎是结局，有没有浇水是过程，因为没有浇水结局不好，所以都想重新开始，但没有人做的到，枯萎了才回去浇水是最终的悔恨</p></blockquote><blockquote><p>不是怕自己过得不好，而是怕别人知道自己过得不好</p></blockquote><h1 id="人，要么孤独，要么庸俗-一"><a href="#人，要么孤独，要么庸俗-一" class="headerlink" title="人，要么孤独，要么庸俗(一)"></a>人，要么孤独，要么庸俗(一)</h1><p>介绍叔本华的另外一本代表作《人生的智慧》，这是叔本华晚年的一部著作，而且还是从叔本华其他著作里面的内容，整理汇编而成的，这本书1860年首次出版，这一年叔本华刚刚去世，叔本华大半生都致力于哲学研究，构建自己的唯意志论哲学体系，但是让叔本华出名的，或者说让大众熟知的并不是一本严肃的哲学著作，可以说在所有的哲学著作里面，《人生的智慧》是叔本华最不“哲学”的哲学书了，但这本书却成了叔本华的代表作，成了超级的畅销书，这可能是叔本华本人都没有想到的。</p><blockquote><p>人生有时候就是这样，往往是无心插柳柳成荫，叔本华的一生并不太顺利，虽然家里很有钱，是个富二代，但父亲在很小的时候就去世了，母亲和他的关系也非常的不好，叔本华的事业和爱情都不怎么样，喜欢的女孩子不喜欢他，他不喜欢的哲学家黑格尔，却如日中天，到处受人追捧，叔本华也只能在他的著作中，骂骂黑格尔是个“江湖骗子”，来解解恨，但在这本书里面，我们看到了叔本华另外一面，那个脾气古怪，傲慢，固执，甚至还有点小气的叔本华不见了，看到的是一个安静 祥和，平静智慧的叔本华，人到晚年也获得了人生的真谛，叔本华认为，<strong>虽然痛苦是人生的主旋律，活着不过是在痛苦和无聊之间左右摇摆而已。但如何在夹缝中获得幸福，却是一种智慧</strong></p></blockquote><p>而这本书告诉了我们这种智慧，，在这本书里面，叔本华把决定人一生的命运的要素分为了三类，</p><ul><li>如何看待自我</li><li>如何看待财富</li><li>如何看待别人的评价</li></ul><p>叔本华以一贯优美而直击灵魂的文字，给我们讲述了他一生的智慧，这本书从1860年首次出版以来，无数次载版，成为了很多人的枕边书，被很多人奉为指导人生的“圣经”，对很多人来说，这本书就像是一座灯塔，让我们终身受益，那接下来我会分为三个部分，来介绍这本书的精彩内容，今天我们先来聊聊，如何看待自我</p><blockquote><p> 亚里士多德，把人生的追求大概分为三类</p><ul><li>第一类是世俗之乐</li><li>第二类是灵魂之乐</li><li>第三类是肉体之乐</li></ul><p> 叔本华认为<strong>最强烈，最丰富最持久的快乐，始终来自于精神上或者灵魂上的愉悦，一个人内在的精神力量的强弱，决定了我们能在多大程度上领略这种快乐，所以人的幸福在很大的程度上，取决于我们自己，也就是自我或者说自我的个性</strong>，叔本华说，人与人之间命运的差异取决于三个方面</p><ul><li>第一个是你的个性</li><li>第二个是你拥有的财富</li><li>第三个是别人如何看待你，或者说你的名誉或者地位，但后面两类显然是外在决定的，而只有第一个你的个性，或者说自我意识才是你正真拥有的</li></ul></blockquote><blockquote><p>个性包括：高尚的品格，聪明的大脑，开朗的性情，愉悦的精神和健康的身体，一言以蔽之，就是健康的心灵和健康的身体，相较于健康的心灵，很多人忽视了健康的身体，对我们幸福的重要程度，但叔本华说，只有在健康的土壤上，才能结出快乐的果实，人到了中年之后，才会意识到健康真的很重要，叔本华有一段关于锻炼身体的论述</p></blockquote><blockquote><p><strong>其实很有意思，他说，很多人不喜欢运动，在他们身上，外在的静止和内在的躁动间，会出现明显的致命的失衡，因为人体内部永不停息的运动，同样需要外部锻炼的配合，即便是一棵树要蓬勃生长，也需要借助风的洗礼</strong></p></blockquote><blockquote><p>叔本华认为，<strong>一个人生活的苦与乐，更多取决于我们的感知方式，我们感受能力的类型和程度，并不是苦乐本身，所以决定一个人是否幸福的主要因素，而且贯穿一生的，就是他的自我，也就是内在的自我的构成，一个人内心的满足和痛苦，只有他的情感，欲望，理性，共同作用的结果，外在的环境只是间接的影响了你的幸福，换句话说，外界的财富物质名誉地位，都只是你获得幸福的手段，而不是最终的目的。</strong></p></blockquote><blockquote><p>比如我们很多人认为，当我们有了很多的钱之后，我们会很幸福，但实际上我们只是把手段当成了目的，让我们真正幸福的，可能是有了钱之后的 <strong>炫耀，虚荣心，满足感</strong>，而有钱或者外在的名誉和地位，都只是我们获得某些内在追求的手段而已，叔本华说，财富就好像是海水，你越喝就越渴，<strong>一个人对世界的认识，来源于我们个体的感受，每个人眼里的世界都是千差万别的，但真正的幸福，在于你的内心如何定义“幸福”</strong>，这取决于你的自我意识，或者说你如何感知这个世界，叔本华认为。人与动物的真正的区别，是拥有强大的感知能力，而不是理性，<strong>感知能力，表现为精神的力量，感知能力越强，所获得的乐趣就越大</strong>，比如那些，不带任何私欲，去体验这个世界的人，也可以通过强大的感知能力，也可以获得快乐和幸福。比如参与有价值的工作，高质量的社交和温暖的家庭聚会，也同样给我们带来了快乐，<strong>但因为人在感知这个世界的同时，欲望也会如影随形</strong>，叔本华认为，<strong>无尽的欲望，导致了痛苦和无聊，是幸福的两大敌人，痛苦和无聊，在欲望的两端，欲望得到了满足就会感到无聊，但欲望无法被满足就会痛苦，痛苦和无聊的对立，是外在客观的，和内在主观之间的对立，艰苦的外在环境导致了痛苦，而当一个人富足之后，就难免会感到无聊，而无聊又导致我们从外在获取新的刺激来满足我们的欲望，叔本华说，为了填补内心的空虚和无聊，我们必须源源不断的追求外在的刺激，比如追求各种无意义的社交，消遣和娱乐，还有人喜欢八卦到处搬弄是非等等，而要避免这样的悲剧，只能依靠内在的力量，也就是丰富的精神思想，因为精神越是丰富，留给无聊的空间就越小，真正的智者会寻求没有痛苦和愤怒的状态，追求闲暇和自由，过上一种平静质朴不受打扰的生活</strong>，所以叔本华说，对所谓的人生，生活有了了解之后，我们就会选择独处，因此智者都喜欢离群索居的生活，一个人内在精神丰富，无需或者极少依仗外物，他也就是最幸福的难怪叔本华说，人，要么孤独，要么庸俗</p></blockquote><h1 id="什么样的人生才是幸福的？（一）"><a href="#什么样的人生才是幸福的？（一）" class="headerlink" title="什么样的人生才是幸福的？（一）"></a>什么样的人生才是幸福的？（一）</h1><p>叔本华把决定人一生命运的因素分为三类：</p><ul><li>如何看待自我</li><li>如何看待财富</li><li>以及如何看待别人的评价</li></ul><p>聊聊后面两个，也就是荣誉，地位，声望。</p><blockquote><p>叔本华说：财富就像海水，越喝越渴，有多少财富人才会满足，才会觉得幸福呢？</p></blockquote><blockquote><p>叔本华说：一个人所拥有的财富的绝对数量，并不是最关键的，<strong>关键的是他拥有财富的数量和他所期望之间的差距有多大</strong>，才是衡量一个人幸福的重要依据</p></blockquote><blockquote><p>因为一个人，因为自己的欲望没有被满足，会感到痛苦，这会让我们的幸福大打折扣</p></blockquote><p>当然这里的重点并不是说，财富对我们来说不重要，在现实世界里面，物质生活需要基本的保障。</p><blockquote><p>叔本华也说：足够的金钱才能带来自由的生活，但是叔本华在这里的重点是说，<strong>伴随着财富的增长，我们的欲望也会与日俱增，所以对欲望的克制才是幸福的关键</strong>，而不是不需要财富</p></blockquote><p>而且叔本华还告诫我们：</p><blockquote><p>在获得了财富之后，穷人比富人更容易挥霍无度，叔本华还详细的对比了，各类人对财富的态度，首先是出生贫寒的人，他们凭借着自己的能力，而获得了巨额的财富，他们总以为自己的才华是自己的资本，所以获得财富只不过是他们，产生了利息而已，所以他们一般不会吧财富转化为固定资产，而是把赚来的钱挥霍一空，但当他们的才华江郎才尽的时候，或者说他们才能被时代淘汰之后，他们又常常会陷入贫困，因为很多人自以为的才能，其实只是在特定的条件下才发挥作用，而他们误以为自己的才华，是永远不变的，低估了才能的适应性，很多人在大公司的高管，离开了公司和大平台之后，往往很难在适应其他环境，其实就是这个道理，个人的才能，往往是非常有限的，更多的情况下是时势造英雄而已</p></blockquote><blockquote><p>其次是，靠真正手艺人赚钱的人，他们的技能不会消失，同行也很难替代，而且这类人的需求永远是有的，这样的人可以凭借着自己的手艺，获得持续不断地收入。</p></blockquote><blockquote><p>第三类是，艺术家或者专业人士，叔本华认为，这些人往往获得大额丰厚的收入，但他们也很少把这些收入转化为资产，而是把这些财富看成是自己的才华，衍生的利息，而挥霍一空。</p></blockquote><blockquote><p>第四类是，财产的继承者，叔本华认为这些人，懂得区分本金和利息，他们大部分人，会尽力保住自己的本金的安全，另外如果有能力的话，他们会把其中的一部分存起来，以备不时之需，因此大部分人都可以维持，自己比较舒适的生活，其实，叔本华，大概就是说自己因为叔本华继承了父亲的大笔的遗产，一生基本上衣食无忧，但是叔本华也是非常保守的人，他住房必须在楼底，以便在可能遇到危险的时候，能迅速逃走，他的墨水瓶下面总是藏着几个金币，以备不时之需等等，可见叔本华，自己也是一个非常谨小慎微，非常保守的人，对金钱也非常的看重</p></blockquote><blockquote><p>最后一类是商人，叔本华认为商人把金钱看成获取财富的工具，就像工人眼中的工具一样，所以他们会尽力运用这笔钱，来实现财富的增值，因此，商人比其他任何阶级的人，都懂的如何运用金钱，在对待金钱的态度上叔本华还认为，出身优越的人，通常比穷人到一夜暴富的人更在乎自己的前途，也更为精打细算，而一夜暴富的人，他们会把金钱看成是，用来可以享受或者挥霍的身外之物，更容易大肆挥霍，如果把钱花光了，他们就会再次陷入贫困，那当然出贫寒的人也有优势，比如，他们的目标就是在仕途上获得成功，有自己的政治抱负，他们会表现得更加的谦卑和低调，然后出身贫寒的人，更有可能得到贵人的帮助，叔本华认为，<strong>人与人之间交往最喜欢做的事情就是证明自己的优越性</strong>，而这一点在政治上其实也是一样的</p></blockquote><p>叔本华如何看待财富。在说一说如何看待别人的评价，而这里的评价是一个比较广泛或者宽泛的概念，包括荣誉地位和声望，这些别人对自己的评价</p><blockquote><p> 存在主义哲学家萨特有句名言，<strong>他人即地狱，人与人之间的交往总是存在争夺主体性，每个人在和他人相处的时候，都把他人变为客体，这种争斗会让我们感觉和他人在一起就如同身处地狱一样</strong>，不知道萨特思想，是不是受到了叔本华的影响，叔本华说，<strong>过分在意他人的评价，是人性的一大弱点</strong>，本在别人的评价对自己的幸福并没有什么影响，但听到他人对自己的好评，或者能满足自己个人虚荣心的话的时候，我们会感到愉悦，那久而久之，<strong>一个人很容易成为他人评价的奴隶</strong>，一个人无法从，自我和外界的财富中找到幸福，而是要从他人对自己的评价中，才能获得满足和幸福，这种人是不幸的。人类存在的基础和幸福的基础，首先是身体的健康，其次是细心维护个人独立自由的能力，那最后叔本华说，幸福主要源自，内心的平和和满足，要增进幸福就要减少人性本能的冲动，要把它控制在，一个合理的范围之内，所谓的荣誉地位和声望都是外在的，都是虚幻的，<strong>名誉是外在的良心，而良心在世内在的名誉</strong>，伟大的灵魂和丰富的智慧，是一个人幸福的关键</p></blockquote><p>《人生的智慧》大概内容说到这里</p><blockquote><p>我们从叔本华的一本博士论文，《论充足理由律的四重根》开始，那介绍了叔本华哲学思想的起点，然后我们介绍了叔本华经典代表作，《作为意志和表象的世界》这本书，介绍了表象的世界，和意志的世界，意志是表现了本质，宇宙万物都是统一意志的客观化，最后介绍了叔本华晚年的一部作品，《人生的智慧》聊到了我们应该如何获取幸福的问题，叔本华的唯意志论哲学和非理性主义哲学，给我留下了深刻的印象，他的“人生的智慧”，也给了很多人深刻的启迪，</p></blockquote><h1 id="如何摆脱欲望的束缚，实现人生的自由"><a href="#如何摆脱欲望的束缚，实现人生的自由" class="headerlink" title="如何摆脱欲望的束缚，实现人生的自由"></a>如何摆脱欲望的束缚，实现人生的自由</h1><blockquote><p>叔本华认为：摆脱生命的痛苦有两种方式，</p><ul><li>一种是进行艺术的审美活动</li><li>一种是践行彻底的禁欲主义</li></ul></blockquote><p>那为什么要进行彻底的禁欲主义，才能摆脱人生的痛苦呢，这是因为意志，有一种根本的特性，就是自由。</p><blockquote><p>意志的自由和人生的痛苦是如何联系起来的呢，叔本华说：<strong>世界是我的表象，表象的世界完全是意志的反应和再现，所以表象世界的本质是意志，意志是一切表象的根源</strong></p></blockquote><p>叔本华说：宇宙万物都是同一的客观话，这是我们得出的一个结论，但是叔本华又说</p><blockquote><p>意志有一个根本的特性那就是自由，自由在今天的价值观里面，是积极和正面的，但在叔本华的哲学思想里面，意志的自由，则完全是不一样的，我们从三个方面来讲</p></blockquote><ul><li><p>首先意志是自由和盲目的，也是具有不确定性的,如果说表现的世界是遵循充足理由律，具有某种确定性，那么意志就是完全随机和盲目的</p></li><li><p>前面介绍了因果律，存在律和动机律，也就是说，表象世界的一切都是有理由的，遵循某种规律和法则的，但是在自由的意志世界里面，意志是盲目的和不确定的，它不遵循充足理由律，它在时间和空间之外，没有逻辑的必然性，也没有因果的必然性，叔本华的意志就是康德的物自体，是我们无法通过理性来认识的，叔本华这种意志的盲目性和随机性和萨特的意识，是非常接近的，萨特说，意识，就像是一个外在与人和世界的幽灵一样，他无影无踪，又不甘寂寞，四处游荡，它就是无，意志有指向性，它无时无刻，不在寻找着什么或者渴望着什么，这是意志自由消极的一面</p></li><li><p>其次，意志的自由是否具有否定性，这种否定性带有某种悲观色彩，在叔本华的哲学悲观里面，意志的自由是一个消极的概念，自由意味着随机性，它的对立面就是必然性或者确定性，所以从某种程度上说，意志的自由，是必然性的一种否定，也就是对自身的一种否定，在人的身上，这种否定性就表现为永远不知满足的欲望，我们总是在欲望的驱使下否定过去，期盼着未来，前面我们介绍了，表象世界是意志的客观化，人的行为都有动机，但是动机的背后，是受意志驱动的，而意志是自由和盲目的，也是永远不知满足的，它永远都不是什么，而是永远即将成为什么，所以叔本华的这种自由的意志观，是略带悲观的，而且和后来萨特存在主义哲学的自由观也是一致的，在萨特的存在主义哲学里面，意识的本质是自由的，我们永远也无法摆脱真正的自由，但自由也意味着责任，所以从某种意义上说这种自由，是种沉重的负担，就像萨特所说的，人真正的不自由，就是永远无法摆脱自由，最后意志是自由的，这也意味着，人是毫无自由的</p><blockquote><p>叔本华说，人是主体和客体的统一体，人也是表象和意志的统一体，意志是绝对自由的，但表象只是意志一种反应或者呈现，所以这里的自由，只是意识层面的自由，而表象则是不自由的，叔本华和萨特的思想，不一样的地方在于，叔本华认为：意志是人的理性所无法掌握的，而萨特认为，人永远都可以凭借理性做出自由的选择，叔本华认为，自由是一种不自觉的连续的盲目的冲动，而这种冲动是我们无法驾驭的，是绝对自由的或者绝对随机的，哲学家大卫·休谟说：理性是且只是激情的奴隶，叔本华认为意志，是一切人类行为的根源，由意志产生欲求，由欲求产生动机，由动机产生活动，那我们要如何才能避免被意志驱使的命运呢，答案之一就是要，践行彻底的禁欲主义，无欲才是人生最后的目的，世界的本质是意志，而在人这里，一直表现为盲目的和永不知满足的欲望，欲望是人生痛苦的来源，所以，我们想要摆脱痛苦，就要摒弃欲望，只有真正的禁止一切的欲望，断绝对世界的任何迷恋，才能进入超然的状态，让自己和世界真正融合在一起，从而获得人生永恒的宁静和解脱，这种对生命的态度有点类似于我国道家思想庄子，庄子形容圣人的状态是，形如槁木</p></blockquote><blockquote><p>庄子还说：吾生也有涯，而知也无涯，已有涯随无涯，殆也。那这些都是略带悲观主义的哲学思想，但当你读完叔本华的哲学思想之后，会发现，叔本华的哲学其实并不那么悲观，而且相反，他给了我们解释悲观和痛苦的另外一种角度，让我们更理性的认识到，痛苦的根源，那从而也化解了，我们对悲伤的痛苦的恐惧，这其实是叔本华哲学，积极和乐观的一面，就像罗曼·罗兰说的：世界上只有一种英雄主义，那就是看透了生活的本质之后，还依然热爱生活，这不正是叔本华哲学，给我们带来的积极和正面的影响吗？</p></blockquote></li></ul><h1 id="分享了叔本华哲学的核心思想"><a href="#分享了叔本华哲学的核心思想" class="headerlink" title="分享了叔本华哲学的核心思想"></a>分享了叔本华哲学的核心思想</h1><blockquote><p>核心关键词：意志</p></blockquote><p>叔本华说：</p><blockquote><p>世界是我的表象，而所有的表象的本质都是意志，，宇宙万物都是统一意志的客体化，这就是叔本华作为唯意志论哲学家的总体的思想概括，</p></blockquote><p>那今天来横向对比一下，叔本华的哲学思想，我们会聊到三个人：</p><blockquote><p>胡塞尔，萨特，老子</p><p>前面介绍了胡塞尔现象学的时候，详细分析了胡塞尔现象学，里面的起点是：意识，在胡塞尔现象学里面，意识具有意向性，这是意识的根本特性，，这一思想其实是从胡塞尔从他的老师，布伦塔洛哪里借用来的，布伦塔洛是德国著名的意动心理学派创始人，布伦塔洛认为，心里现象或者意识的本质是意向性，一切意识都是关于对象的意识，不可能有意识但没有意识的对象，所以意识的本质就是意向性，意识总是对应着外在的对象，或者说意识，就是意识到某个对象，胡塞尔在此基础上，构建了自己纯粹意识的现象学，胡塞尔现象学提出的口号是，回到事情本身，其实，也就是让我们回到主体和客体融合，现象和本质相互交融的纯粹意识的领域去认识事物</p></blockquote><p>虽然胡塞尔和叔本华的思想体系，是完全不同的，但是他们的思想的起点其实是类似的，叔本华说，意志的本质就是要巍峨表现出，现象而存在的换句话说，在叔本华这里，是自由的是盲目的，而且意志的本质，就是要表现为现象，这和胡塞尔的意识的意向性，其实是类似的，，胡塞尔说，印象活动是赋予意义的活动，在意向活动里面即使是最简单的表现，也赋予了意义和内涵，胡塞尔的意识和叔本华的意志，都具有自由和盲目的特性，但都指向某个对象，这是他们的共同点</p><blockquote><p>萨特的存在主义思想，在萨特哲学思想的起点也是意识，萨特有句名言，人真正的不自由，就是永远也无法摆脱自由，这句话听起来非常的反直觉，为什么人永远无法摆脱自由呢，自由其实是人本质特性，而这种本质特性，其实是意识赋予的，在萨特的哲学思想里面，意识具有指向性，有自发性，意识也是绝对自由的，萨特说，意识是自由的，可以赋予人以意义和自由，但是意识本身，其实是空洞和盲目的，没有任何意义的意识具有指向性，它永远在寻找或者依附的对象，永远在指某物</p></blockquote><p>比如我们为您眼前看到的苹果，大脑里面会想着某个人，那这些都是意识作用，但是如果没有我这个主体意识，意识就毫无意义，就像空气中的一缕青烟，萨特说，意志就像一个外在于人和世界的幽灵一样，他无影无相却，又不甘寂寞四处游荡，，它就是无。萨特的意识和叔本华的意志其实也是类似的，意识和意志都具有自由的特性。而且都是绝对的自由，也是绝对的盲目，没有任何的确定的目的，所以意志在人生上就表现为永远不知满足的欲望，从而导致了人生对欲望的永恒的追求，这种追求是痛苦的，萨特看到了意识的自由特性，意识赋予了人存在的意义和自由，但是意识也意味着责任，自由是一种沉重的负担，是我们永远也无法摆脱的责任</p><blockquote><p>叔本华的意志和道家思想的道，老子说宇宙万物都是由道演化而来的，道生一，一生二，二生三，三生万物，而且在道家思想里面，道也是无影无踪，无形无体。老子说，道之为物，唯恍唯惚，惚兮恍兮，其中有象，恍兮惚兮，其中有物，那大概意思是说，道这种东西，没有清晰的固定的实体，它总是恍恍惚惚，其中却有形象，它总是恍恍惚惚的，其中却有实物。道生成万物，而道又在万物之中，道是万物的本源，也是万物表象背后的本质，这是道家思想的内涵，那其实叔本华的意志也表达了类似的意思，叔本华说宇宙万物都是同一意志的客体化，世界是我的表象，而表象的本质就是意志，意志具有绝对的自由，意志又无处不在，却又生生不息，</p></blockquote><blockquote><p>从柏拉图的理念，道笛卡尔的我思，再到康德的物自体，黑格尔的绝对精神，以及叔本华的意志，每一代哲学家都试图找到世界，存在的基础，和万物存在的本质，他们思想的共同点，就是认为现象背后有一个永恒的东西，它，才是世界的本质，这种思想在哲学里面称之为：本质主义，但这个世界真的有本质吗？还是我们一种美好的愿望呢，这值得深思</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven</title>
      <link href="posts/c6e613d8.html"/>
      <url>posts/c6e613d8.html</url>
      
        <content type="html"><![CDATA[<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载地址：<a href="http://maven.apache.org/download.cgi">http://maven.apache.org/download.cgi</a></p><p><img src="https://cdn.jsdelivr.net/gh/unluckynike/blogimg/images/MavenDownload.png" alt="img"></p><p>下载完，直接解压，copy到一个无中文的目录，并且创建一个新的epository目录，这是本地仓库目录。一下便是解压后的Maven目录结构。</p><p><img src="https://7.dusays.com/2021/03/23/af19e67c05864.png"></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>1.首先确保电脑JDK已经安装好，进入环境变量的系统变量新建变量名<code>MAVEN_HOME</code>，值为刚才解压的Maven文件的路径。</p><p><img src="https://7.dusays.com/2021/03/23/92c45cd5d93d2.png"></p><p>2.确认后再进入到系统变量的<code>Path</code>新建<code>%MAVEN_HOME%\bin</code></p><p><img src="https://7.dusays.com/2021/03/23/bb1e879c90496.png"></p><p>3.在cmd窗口输入<code>mvn -v</code>显示出版本信息则说明已经配置成功。</p><h2 id="先照着配置"><a href="#先照着配置" class="headerlink" title="先照着配置"></a>先照着配置</h2><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p><strong>修改Repository</strong></p><p>进入<code>conf\settings.xml</code>文件在标签内修改它的默认存储路径。</p><h4 id="（1）配置路径-先建立好这个文件夹"><a href="#（1）配置路径-先建立好这个文件夹" class="headerlink" title="（1）配置路径 先建立好这个文件夹"></a>（1）配置路径 先建立好这个文件夹</h4><pre class="line-numbers language-none"><code class="language-none">&lt;localRepository&gt;D:/repository&lt;/localRepository&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="（2）配置阿里云镜像-要不啥也下不动"><a href="#（2）配置阿里云镜像-要不啥也下不动" class="headerlink" title="（2）配置阿里云镜像 要不啥也下不动"></a>（2）配置阿里云镜像 要不啥也下不动</h4><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrors</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirror</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>alimaven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">&gt;</span></span>aliyun maven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">&gt;</span></span>http://maven.aliyun.com/nexus/content/groups/public/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrorOf</span><span class="token punctuation">&gt;</span></span>central<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirrorOf</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirror</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrors</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（3）配置全局编译jdk版本"><a href="#（3）配置全局编译jdk版本" class="headerlink" title="（3）配置全局编译jdk版本"></a>（3）配置全局编译jdk版本</h4><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profile</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>jdk-1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activation</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activeByDefault</span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activeByDefault</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jdk</span><span class="token punctuation">&gt;</span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jdk</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activation</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maven.compiler.source</span><span class="token punctuation">&gt;</span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maven.compiler.source</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maven.compiler.target</span><span class="token punctuation">&gt;</span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maven.compiler.target</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maven.compiler.compilerVersion</span><span class="token punctuation">&gt;</span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maven.compiler.compilerVersion</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profile</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>maven标准目录</p></blockquote><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">src|--main|--java 源代码目录|--resources 资源目录|--test|--java 测试代码目录|--resources 测试资源目录|--target|--classes 编译后的class文件目录|--test-classes 编译后的测试class文件目录pom.xml Maven工程配置文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是大部分Maven工程的目录结构，在这个基础上可以合理地增删目录。 pom.xml的基本要求：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">&gt;</span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.xinzhi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Maven生命周期"><a href="#Maven生命周期" class="headerlink" title="Maven生命周期"></a>Maven生命周期</h2><blockquote><p>maven生命周期其实就是描述了一个项目从源代码到部署的整个周期</p></blockquote><p>Maven有三个内置的生命周期：<strong>默认（default），清洁（clean）和站点（site）。</strong></p><ul><li>清洁（clean） 为执行以下工作做必要的清理。就是我们经常做的，删除target文件夹。</li><li> 默认（default） 真正进行项目编译打包等工作的阶段</li><li> 站点（site） 生成项目报告，站点，发布站点</li></ul><blockquote><p>默认（default）的生命周期包括以下阶段（该阶段经过简化，实际上更加复杂）：</p></blockquote><ol><li>验证（validate） - 验证项目是否正确，所有必要的信息可用。</li><li> 编译（compile） - 编译项目的源代码。 </li><li>测试（test） - 使用合适的单元测试框架测试编译的源代码。这些测试不应该要求代码被打包 或部署。 </li><li> 打包（package）- 采用编译的代码，并以其可分配格式（如JAR）进行打包。</li><li>  验证（verify） - 对集成测试的结果执行任何检查，以确保满足质量标准。</li><li>  安装（install） - 将软件包安装到本地存储库中，用作本地其他项目的依赖项。</li><li> 部署（deploy） - 在构建环境中完成，将最终的包复制到远程存储库以与其他开发人员和项目共享 （私服）。</li></ol><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">mvn install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此命令在执行安装之前按顺序（验证（validate），编译（compile），打包（package）等）执行每个 默认生命周期阶段。在这种情况下，您只需要调用最后一个构建阶段来执行，安装（install）。</p><p> 在构建环境中，使用以下调用将工件清理地构建并部署到共享存储库中。</p><pre class="line-numbers language-none"><code class="language-none">mvn clean deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>相同的命令可以在多模块场景（即具有一个或多个子项目的项目）中使用。Maven遍历每个子项目并执 行清洁（clean），然后执行部署（deploy）（包括所有之前的构建阶段步骤）。</p><p> 注意：在我们开发阶段，有一些生命周期的阶段，比如验证（validate）这些，基本很少用到。只要使 用关键的几个基本能满足需求。</p><h2 id="Maven-常用命令"><a href="#Maven-常用命令" class="headerlink" title="Maven 常用命令"></a>Maven 常用命令</h2><p>下面maven比较常见的一些命令。</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>mvn –version</td><td>显示版本信息</td></tr><tr><td>mvn clean</td><td>清理项目生产的临时文件,一般是模块下的target目录</td></tr><tr><td>mvn compile</td><td>编译源代码，一般编译模块下的src/main/java目录</td></tr><tr><td>mvn package</td><td>项目打包工具,会在模块下的target目录生成jar或war等文件</td></tr><tr><td>mvn test</td><td>测试命令,或执行src/test/java/下junit的测试用例</td></tr><tr><td>mvn install</td><td>将打包的jar/war文件复制到你的本地仓库中,供其他模块使用</td></tr><tr><td>mvn deploy</td><td>将打包的文件发布到远程参考,提供其他人员进行下载依赖</td></tr><tr><td>mvn site</td><td>生成项目相关信息的网站</td></tr><tr><td>mvn dependency:tree</td><td>mvn dependency:tree</td></tr><tr><td>mvn archetype:generate</td><td>创建Maven的普通java项目</td></tr><tr><td>mvn tomcat:run</td><td>在tomcat容器中运行web应用</td></tr></tbody></table><h2 id="Maven的版本规范"><a href="#Maven的版本规范" class="headerlink" title="Maven的版本规范"></a>Maven的版本规范</h2><p>所有的软件都用版本 </p><p>Maven使用如下几个要素来定位一个项目，因此它们又称为项目的坐标。</p><blockquote><ul><li><strong>groudId</strong> 团体、组织的标识符。团体标识的约定是，它以创建这个项目的组织名称的逆向域名开 头。一般对应着JAVA的包的结构，例如org.apache。</li><li> <strong>artifactId</strong> 单独项目的唯一标识符。比如我们的tomcat, commons等。不要在artifactId中包含 点号(.)。</li><li> <strong>version</strong> 项目的版本。</li><li> <strong>packaging</strong> 项目的类型，默认是jar，描述了项目打包后的输出。类型为jar的项目产生一个JAR文 件，类型为war的项目产生一个web应用。</li><li> Maven在版本管理时候可以使用几个特殊的字符串 SNAPSHOT，LATEST，RELEASE。比如”1.0- SNAPSHOT”。各个部分的含义和处理逻辑如下说明：</li><li> <strong>SNAPSHOT</strong> 这个版本一般用于开发过程中，表示不稳定的版本。 </li><li><strong>LATEST</strong> 指某个特定构件的最新发布，这个发布可能是一个发布版，也可能是一个snapshot版，具 体看哪个时间最后。 </li><li><strong>RELEASE</strong> 指最后一个发布版。</li></ul></blockquote><h2 id="在idea中配置maven"><a href="#在idea中配置maven" class="headerlink" title="在idea中配置maven"></a>在idea中配置maven</h2><blockquote><p> 把画红线的东西全部配置成自己的。最后一个是仓库，在你的其他盘找一个地方新建repository文 件夹，自己要知道，选中，如果勾选不了就选择都选override。 如果不选择仓库会把jar包下载至C盘的下边目录，不好维护，还占用c盘空间。当然idea和maven可能会 有bug</p></blockquote><pre class="line-numbers language-none"><code class="language-none">C:\Users\zn\.m2\repository<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://7.dusays.com/2021/03/23/b0ec1a73224e2.png"></p><blockquote><p>两处都要配置，一个是当前项目的maven配置，一个是新建项目的maven配置。</p></blockquote><p><img src="https://7.dusays.com/2021/03/23/30d243b137ce6.png"></p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
            <tag> 项目构建工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一首小诗，你可否愿意像我一样</title>
      <link href="posts/a642e0de.html"/>
      <url>posts/a642e0de.html</url>
      
        <content type="html"><![CDATA[<div class="ipage"> <div class="ititle">你可否愿意像我一样<br>  <span style="align=right; color:#0093E9;font-size:18px;">-----CodeCheng</span>  </div> <div class="izhengwen" style="align=center;"> <p style="align=center">当夜如锦被般铺展开来</p>  <p>悠悠寒夜，只剩点点星光</p>  <p>路灯下的我举头仰望</p>  <p>孤寂的星辰，孤独的我</p>  <p>此刻你是否想我</p>  <p>像我一样，渴望又绝望</p><br>  <hr> <p>当四季的轮换那样翩然而至</p>    <p>时光荏苒，山海苍茫</p>    <p>走得最快的，都是和你最美的时光</p>    <p>还没有来得及，说对不起</p>    <p>在靓丽的外表下，会发现跌落到尘埃里的我</p>    <p>情到深处无怨尤</p>    <p>你可否可以，像我一样</p> <br><hr>  <p>当岁月的风霜那样的跋扈的不近人情</p>   <p>风华双鬓，芳容憔悴</p>     <p>还没来得及，伴你同行天涯</p>     <p>看你笑靥如花，陪你诗酒茶花</p>     <p>浅浅淡淡的日子</p>     <p>愿岁月静好，温馨可期</p>     <p>日子过得久了，尚有一些美好的回忆</p>     <p>你可否愿意，像我一样</p>     <br><p style="algin=center;color:#AEB4B5;"><b>我曾向这冷漠的世界下跪，输掉一切，就让我来次透彻心扉的痛</b></p></div> </div><div style="algin=center;color:#FF6A88;">  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="530" height="86" src="//music.163.com/outchain/player?type=2&amp;id=484732973&amp;auto=1&amp;height=66" style="algin=center;"> </iframe></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 心情 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 心情 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心情随笔</title>
      <link href="posts/f77810a8.html"/>
      <url>posts/f77810a8.html</url>
      
        <content type="html"><![CDATA[<div class="ipage">   <div class="ititle">学会微笑</div>   <div class="izhengwen">    <p> If not to the sun for smiling, warm is still in the sun there, but we will laugh more confident calm; 如果不是太阳微笑，温暖仍然在阳光下，但我们会笑得更加自信; </p>     <p>if turned to found his own shadow, appropriate escape, the sun will be through the heart,warm each place behind the corner;     如果转向发现自己的影子，适当的逃脱，太阳将通过心脏，温暖在角落后面的每个地方;</p>     <p>if an outstretched palm cannot fall butterfly, then clenched waving arms, given power; 如果一个伸出的棕榈不能落下蝴蝶，那就握紧挥动臂，给予功率;</p>     <p>if I cant have bright smile, it will face to the sunshine, and sunshine smile togeth如果我不能微笑，它将面对阳光，阳光微笑到可见 </p>     <p>人生忽如寄，莫辜负茶、汤、好天气。                                                         ------codecheng    </p>  </div> </div>]]></content>
      
      
      <categories>
          
          <category> 生活感悟 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode常用插件</title>
      <link href="posts/510fa095.html"/>
      <url>posts/510fa095.html</url>
      
        <content type="html"><![CDATA[<h2 id="vscode常用插件"><a href="#vscode常用插件" class="headerlink" title="vscode常用插件"></a>vscode常用插件</h2><h3 id="1、markdow-preview-enhanced"><a href="#1、markdow-preview-enhanced" class="headerlink" title="1、markdow preview  enhanced"></a>1、markdow preview  enhanced</h3><p>markdown预览</p><h3 id="2、code-runner"><a href="#2、code-runner" class="headerlink" title="2、code runner"></a>2、code runner</h3><p>支持多语言的立即执行</p><h3 id="3、vs-color-picker"><a href="#3、vs-color-picker" class="headerlink" title="3、vs color picker"></a>3、vs color picker</h3><p> 颜色选择器</p><h3 id="4、Beautify"><a href="#4、Beautify" class="headerlink" title="4、Beautify"></a>4、Beautify</h3><p>推荐指数⭐⭐⭐⭐</p><p>最常用的，使用于代码格式化，用于整理代码格式化代码规则,支持HTMl CSS JAVASCRIPT代码格式化</p><p><img src="https://upload-images.jianshu.io/upload_images/20492697-f7650eaa231c8d8c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/588/format/webp" alt="img"></p><p>在线服务器</p><p>推荐指数⭐⭐⭐⭐⭐</p><p>为静态和动态页面启动具有实时重新加载功能的开发本地服务器,以127.0.0.1形式打开服务器，如果没有装，打开的形式是以file协议打开，并不能热更新，强烈推荐前端使用此插件</p><h3 id="5、HTML-CSS-Support"><a href="#5、HTML-CSS-Support" class="headerlink" title="5、HTML CSS Support"></a>5、HTML CSS Support</h3><p>推荐指数⭐⭐⭐⭐</p><p>智能提示HTML标签，以及标签含义</p><p><img src="https://upload-images.jianshu.io/upload_images/20492697-4fd22f79112316ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><h3 id="6、jQuery-Code-Snippets"><a href="#6、jQuery-Code-Snippets" class="headerlink" title="6、jQuery Code Snippets"></a>6、jQuery Code Snippets</h3><p>推荐指数⭐⭐⭐⭐</p><p>Jquery代码智能提示，自动补全</p><p>Bootstrap 3 Snippets</p><p>推荐指数⭐⭐⭐⭐</p><p>Bootstrap代码智能提示，自动补全，这款Bootstrap框架是一款很流行的支持响应式框架，简单快捷。</p><p><img src="https://upload-images.jianshu.io/upload_images/20492697-0859ec5a4df78af4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/818/format/webp" alt="img"></p><h3 id="7、Chinese-Simplified-Language-Pack-for-Visual-Studio-Code"><a href="#7、Chinese-Simplified-Language-Pack-for-Visual-Studio-Code" class="headerlink" title="7、Chinese (Simplified) Language Pack for Visual Studio Code"></a>7、Chinese (Simplified) Language Pack for Visual Studio Code</h3><p>推荐指数⭐⭐⭐⭐</p><p>适用于VS CODE的中文（简体）语言包</p><p><img src="https://upload-images.jianshu.io/upload_images/20492697-6d24e2ff4f7d0880.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1055/format/webp" alt="img"></p><h3 id="8、Regex-Previewer"><a href="#8、Regex-Previewer" class="headerlink" title="8、Regex Previewer"></a>8、Regex Previewer</h3><p>推荐指数⭐⭐⭐⭐</p><p>正则表达式预览器，Regex匹配Visual Studio代码中JavaScript、TypeScript、PHP和Haxe的预览器。</p><p><img src="https://upload-images.jianshu.io/upload_images/20492697-63083dc3fafb7ea9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/889/format/webp" alt="img"></p><h3 id="9、Vetur-【vue-js必备】"><a href="#9、Vetur-【vue-js必备】" class="headerlink" title="9、Vetur 【vue.js必备】"></a>9、Vetur 【vue.js必备】</h3><p>推荐指数⭐⭐⭐⭐⭐</p><p>Vue多功能集成插件，语法高亮，智能提示，emmet，错误提示，格式化，自动补全，debugger。vscode官方钦定Vue插件，Vue开发者必备。</p><p><img src="https://upload-images.jianshu.io/upload_images/20492697-605c97ca7c54fd97.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1092/format/webp" alt="img"></p><h3 id="10、Dracula-Official"><a href="#10、Dracula-Official" class="headerlink" title="10、Dracula Official"></a>10、Dracula Official</h3><p>推荐指数⭐⭐⭐⭐⭐</p><p>主题风格插件，一款超级赞</p><h3 id="11、Npm-Intellisense【node-js必备】"><a href="#11、Npm-Intellisense【node-js必备】" class="headerlink" title="11、Npm Intellisense【node.js必备】"></a>11、Npm Intellisense【node.js必备】</h3><p>推荐指数⭐⭐⭐⭐⭐</p><p>在import语句中自动完成npm模块的Visual Studio代码插件</p><p><img src="https://upload-images.jianshu.io/upload_images/20492697-dac40b7a3bb12f69.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/859/format/webp" alt="img"></p><h2 id="最最常用的vscode-快捷键"><a href="#最最常用的vscode-快捷键" class="headerlink" title="最最常用的vscode 快捷键"></a>最最常用的vscode 快捷键</h2><ol><li><code>Alt + Shift+ click(doublce)</code> : 列编辑 安住alt+ shift 键 鼠标 在起始列 终止列 点击2次 即可 配合 (<code>ctrl+shift+ -&gt;</code> 选中单词 <code>ctrl+C ctrl+v</code> 拷贝/粘贴 <code>ctrl+shift+home/end</code> 光标移动到列首 列尾 超好用 极力推荐 )</li><li><code>Ctrl + Shift + ?</code> : 注释 取消 注释 需要先选中</li><li><code>Ctrl + V Ctrl +V</code> : 复制 粘贴</li><li><code>Alt + Click</code>: 键盘Alt + 鼠标点击 多处编辑</li><li><code>Ctrl + up/down</code> : 行顺序切换</li></ol><hr><h2 id="通用快捷键"><a href="#通用快捷键" class="headerlink" title="通用快捷键"></a>通用快捷键</h2><table><thead><tr><th align="left">快捷键</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Ctrl+Shift+P,F1</td><td align="left">展示全局命令面板</td></tr><tr><td align="left">Ctrl+P</td><td align="left">快速打开最近打开的文件</td></tr><tr><td align="left">Ctrl+Shift+N</td><td align="left">打开新的编辑器窗口</td></tr><tr><td align="left">Ctrl+Shift+W</td><td align="left">关闭编辑器</td></tr></tbody></table><hr><h2 id="基础编辑"><a href="#基础编辑" class="headerlink" title="基础编辑"></a>基础编辑</h2><table><thead><tr><th align="left">快捷键</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Ctrl + X</td><td align="left">剪切</td></tr><tr><td align="left">Ctrl + C</td><td align="left">复制</td></tr><tr><td align="left">Alt + up/down</td><td align="left">移动行上下</td></tr><tr><td align="left">Shift + Alt up/down</td><td align="left">在当前行上下复制当前行</td></tr><tr><td align="left">Ctrl + Shift + K</td><td align="left">删除行</td></tr><tr><td align="left">Ctrl + Enter</td><td align="left">在当前行下插入新的一行</td></tr><tr><td align="left">Ctrl + Shift + Enter</td><td align="left">在当前行上插入新的一行</td></tr><tr><td align="left">Ctrl + Shift + | 匹配花括号的闭合处，跳转</td><td align="left"></td></tr><tr><td align="left">Ctrl + ] / [</td><td align="left">行缩进</td></tr><tr><td align="left">Home</td><td align="left">光标跳转到行头</td></tr><tr><td align="left">End</td><td align="left">光标跳转到行尾</td></tr><tr><td align="left">Ctrl + Home</td><td align="left">跳转到页头</td></tr><tr><td align="left">Ctrl + End</td><td align="left">跳转到页尾</td></tr><tr><td align="left">Ctrl + up/down</td><td align="left">行视图上下偏移</td></tr><tr><td align="left">Alt + PgUp/PgDown</td><td align="left">屏视图上下偏移</td></tr><tr><td align="left">Ctrl + Shift + [</td><td align="left">折叠区域代码</td></tr><tr><td align="left">Ctrl + Shift + ]</td><td align="left">展开区域代码</td></tr><tr><td align="left">Ctrl + K Ctrl + [</td><td align="left">折叠所有子区域代码</td></tr><tr><td align="left">Ctrl + k Ctrl + ]</td><td align="left">展开所有折叠的子区域代码</td></tr><tr><td align="left">Ctrl + K Ctrl + 0</td><td align="left">折叠所有区域代码</td></tr><tr><td align="left">Ctrl + K Ctrl + J</td><td align="left">展开所有折叠区域代码</td></tr><tr><td align="left">Ctrl + K Ctrl + C</td><td align="left">添加行注释</td></tr><tr><td align="left">Ctrl + K Ctrl + U</td><td align="left">删除行注释</td></tr><tr><td align="left">Ctrl + /</td><td align="left">添加关闭行注释</td></tr><tr><td align="left">Shift + Alt +A</td><td align="left">块区域注释</td></tr><tr><td align="left">Alt + Z</td><td align="left">添加关闭词汇包含</td></tr></tbody></table><hr><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><table><thead><tr><th align="left">快捷键</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Ctrl + T</td><td align="left">列出所有符号</td></tr><tr><td align="left">Ctrl + G</td><td align="left">跳转行</td></tr><tr><td align="left">Ctrl + P</td><td align="left">跳转文件</td></tr><tr><td align="left">Ctrl + Shift + O</td><td align="left">跳转到符号处</td></tr><tr><td align="left">Ctrl + Shift + M</td><td align="left">打开问题展示面板</td></tr><tr><td align="left">F8</td><td align="left">跳转到下一个错误或者警告</td></tr><tr><td align="left">Shift + F8</td><td align="left">跳转到上一个错误或者警告</td></tr><tr><td align="left">Ctrl + Shift + Tab</td><td align="left">切换到最近打开的文件</td></tr><tr><td align="left">Alt + left / right</td><td align="left">向后、向前</td></tr><tr><td align="left">Ctrl + M</td><td align="left">进入用Tab来移动焦点</td></tr></tbody></table><hr><h2 id="查询与替换"><a href="#查询与替换" class="headerlink" title="查询与替换"></a>查询与替换</h2><table><thead><tr><th align="left">快捷键</th><th align="left">作用</th><th></th></tr></thead><tbody><tr><td align="left">Ctrl + F</td><td align="left">查询</td><td></td></tr><tr><td align="left">Ctrl + H</td><td align="left">替换</td><td></td></tr><tr><td align="left">F3 / Shift + F3</td><td align="left">查询下一个/上一个</td><td></td></tr><tr><td align="left">Alt + Enter</td><td align="left">选中所有出现在查询中的</td><td></td></tr><tr><td align="left">Ctrl + D</td><td align="left">匹配当前选中的词汇或者行，再次选中-可操作</td><td></td></tr><tr><td align="left">Ctrl + K Ctrl + D</td><td align="left">移动当前选择到下个匹配选择的位置(光标选定)</td><td></td></tr><tr><td align="left">Alt + C / R / W</td><td align="left"></td><td>不分大小写/使用正则/全字匹配</td></tr></tbody></table><hr><h2 id="多行光标操作于选择"><a href="#多行光标操作于选择" class="headerlink" title="多行光标操作于选择"></a>多行光标操作于选择</h2><table><thead><tr><th align="left">快捷键</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Alt + Click</td><td align="left">插入光标-支持多个</td></tr><tr><td align="left">Ctrl + Alt + up/down</td><td align="left">上下插入光标-支持多个</td></tr><tr><td align="left">Ctrl + U</td><td align="left">撤销最后一次光标操作</td></tr><tr><td align="left">Shift + Alt + I</td><td align="left">插入光标到选中范围内所有行结束符</td></tr><tr><td align="left">Ctrl + I</td><td align="left">选中当前行</td></tr><tr><td align="left">Ctrl + Shift + L</td><td align="left">选择所有出现在当前选中的行-操作</td></tr><tr><td align="left">Ctrl + F2</td><td align="left">选择所有出现在当前选中的词汇-操作</td></tr><tr><td align="left">Shift + Alt + right</td><td align="left">从光标处扩展选中全行</td></tr><tr><td align="left">Shift + Alt + left</td><td align="left">收缩选择区域</td></tr><tr><td align="left">Shift + Alt + (drag mouse)</td><td align="left">鼠标拖动区域，同时在多个行结束符插入光标</td></tr><tr><td align="left">Ctrl + Shift + Alt + (Arrow Key)</td><td align="left">也是插入多行光标的[方向键控制]</td></tr><tr><td align="left">Ctrl + Shift + Alt + PgUp/PgDown</td><td align="left">也是插入多行光标的[整屏生效]</td></tr></tbody></table><hr><h2 id="丰富的语言操作"><a href="#丰富的语言操作" class="headerlink" title="丰富的语言操作"></a>丰富的语言操作</h2><table><thead><tr><th align="left">快捷键</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Ctrl + Space</td><td align="left">输入建议[智能提示]</td></tr><tr><td align="left">Ctrl + Shift + Space</td><td align="left">参数提示</td></tr><tr><td align="left">Tab</td><td align="left">Emmet指令触发/缩进</td></tr><tr><td align="left">Shift + Alt + F</td><td align="left">格式化代码</td></tr><tr><td align="left">Ctrl + K Ctrl + F</td><td align="left">格式化选中部分的代码</td></tr><tr><td align="left">F12</td><td align="left">跳转到定义处</td></tr><tr><td align="left">Alt + F12</td><td align="left">代码片段显示定义</td></tr><tr><td align="left">Ctrl + K F12</td><td align="left">在其他窗口打开定义处</td></tr><tr><td align="left">Ctrl + .</td><td align="left">快速修复部分可以修复的语法错误</td></tr><tr><td align="left">Shift + F12</td><td align="left">显示所有引用</td></tr><tr><td align="left">F2</td><td align="left">重命名符号</td></tr><tr><td align="left">Ctrl + Shift + . / ,</td><td align="left">替换下个值</td></tr><tr><td align="left">Ctrl + K Ctrl + X</td><td align="left">移除空白字符</td></tr><tr><td align="left">Ctrl + K M</td><td align="left">更改页面文档格式</td></tr></tbody></table><hr><h2 id="编辑器管理"><a href="#编辑器管理" class="headerlink" title="编辑器管理"></a>编辑器管理</h2><table><thead><tr><th align="left">快捷键</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Ctrl + F4, Ctrl + W</td><td align="left">关闭编辑器</td></tr><tr><td align="left">Ctrl + k F</td><td align="left">关闭当前打开的文件夹</td></tr><tr><td align="left">Ctrl + |切割编辑窗口</td><td align="left"></td></tr><tr><td align="left">Ctrl + 1/2/3</td><td align="left">切换焦点在不同的切割窗口</td></tr><tr><td align="left">Ctrl + K Ctrl &lt;-/-&gt;</td><td align="left">切换焦点在不同的切割窗口</td></tr><tr><td align="left">Ctrl + Shift + PgUp/PgDown</td><td align="left">切换标签页的位置</td></tr><tr><td align="left">Ctrl + K &lt;-/-&gt;</td><td align="left">切割窗口位置调换</td></tr></tbody></table><hr><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><table><thead><tr><th align="left">快捷键</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Ctrl + N</td><td align="left">新建文件</td></tr><tr><td align="left">Ctrl + O</td><td align="left">打开文件</td></tr><tr><td align="left">Ctrl + S</td><td align="left">保存文件</td></tr><tr><td align="left">Ctrl + Shift + S</td><td align="left">另存为</td></tr><tr><td align="left">Ctrl + K S</td><td align="left">保存所有当前已经打开的文件</td></tr><tr><td align="left">Ctrl + F4</td><td align="left">关闭当前编辑窗口</td></tr><tr><td align="left">Ctrl + K Ctrl + W</td><td align="left">关闭所有编辑窗口</td></tr><tr><td align="left">Ctrl + Shift + T</td><td align="left">撤销最近关闭的一个文件编辑窗口</td></tr><tr><td align="left">Ctrl + K Enter</td><td align="left">保持开启</td></tr><tr><td align="left">Ctrl + Shift + Tab</td><td align="left">调出最近打开的文件列表，重复按会切换</td></tr><tr><td align="left">Ctrl + Tab</td><td align="left">与上面一致，顺序不一致</td></tr><tr><td align="left">Ctrl + K P</td><td align="left">复制当前打开文件的存放路径</td></tr><tr><td align="left">Ctrl + K R</td><td align="left">打开当前编辑文件存放位置【文件管理器】</td></tr><tr><td align="left">Ctrl + K O</td><td align="left">在新的编辑器中打开当前编辑的文件</td></tr></tbody></table><hr><h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><table><thead><tr><th align="left">快捷键</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">F11</td><td align="left">切换全屏模式</td></tr><tr><td align="left">Shift + Alt + 1</td><td align="left">切换编辑布局【目前无效】</td></tr><tr><td align="left">Ctrl + =/-</td><td align="left">放大 / 缩小</td></tr><tr><td align="left">Ctrl + B</td><td align="left">侧边栏显示隐藏</td></tr><tr><td align="left">Ctrl + Shift + E</td><td align="left">资源视图和编辑视图的焦点切换</td></tr><tr><td align="left">Ctrl + Shift + F</td><td align="left">打开全局搜索</td></tr><tr><td align="left">Ctrl + Shift + G</td><td align="left">打开Git可视管理</td></tr><tr><td align="left">Ctrl + Shift + D</td><td align="left">打开DeBug面板</td></tr><tr><td align="left">Ctrl + Shift + X</td><td align="left">打开插件市场面板</td></tr><tr><td align="left">Ctrl + Shift + H</td><td align="left">在当前文件替换查询替换</td></tr><tr><td align="left">Ctrl + Shift + J</td><td align="left">开启详细查询</td></tr><tr><td align="left">Ctrl + Shift + V</td><td align="left">预览Markdown文件【编译后】</td></tr><tr><td align="left">Ctrl + K v</td><td align="left">在边栏打开渲染后的视图【新建】</td></tr></tbody></table><hr><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><table><thead><tr><th align="left">快捷键</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">F9</td><td align="left">添加解除断点</td></tr><tr><td align="left">F5</td><td align="left">启动调试、继续</td></tr><tr><td align="left">F11 / Shift + F11</td><td align="left">单步进入 / 单步跳出</td></tr><tr><td align="left">F10</td><td align="left">单步跳过</td></tr><tr><td align="left">Ctrl + K Ctrl + I</td><td align="left">显示悬浮</td></tr></tbody></table><hr><h2 id="集成终端"><a href="#集成终端" class="headerlink" title="集成终端"></a>集成终端</h2><table><thead><tr><th align="left">快捷键</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Ctrl + `</td><td align="left">打开集成终端</td></tr><tr><td align="left">Ctrl + Shift + `</td><td align="left">创建一个新的终端</td></tr><tr><td align="left">Ctrl + Shift + C</td><td align="left">复制所选</td></tr><tr><td align="left">Ctrl + Shift + V</td><td align="left">复制到当前激活的终端</td></tr><tr><td align="left">Shift + PgUp / PgDown</td><td align="left">页面上下翻屏</td></tr><tr><td align="left">Ctrl + Home / End</td><td align="left">滚动到页面头部或尾部</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> vscode </category>
          
          <category> 插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端工具 </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP九大内置对象</title>
      <link href="posts/21b8264b.html"/>
      <url>posts/21b8264b.html</url>
      
        <content type="html"><![CDATA[<h1 id="JSP九大内置对象"><a href="#JSP九大内置对象" class="headerlink" title="JSP九大内置对象"></a>JSP九大内置对象</h1><h2 id="1-request-对象"><a href="#1-request-对象" class="headerlink" title="1. request 对象 :"></a>1. request 对象 :</h2><blockquote><p>代表的是来自客户端的请求 , 客户端发送的请求封装在 request 对象中 , 通过它才能了解到用户的请求信息 , 然后作出响应 , 它是 HTTPServletRequest 的实例 , 作用域为 request ( 响应生成之前 )</p></blockquote><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">Object getAttribute(String name);// 返回指定属性的属性值void setAttribute(String key, Object value);// 设置属性的属性值Enumeration getAttributeNames();// 返回所有可以用属性名的枚举String getParameter(String name);// 返回指定name的参数值Enumeration getParameterNames();// 返回可用参数名的枚举String[] getParameterValues(String name);// 返回包含参数name的所有制的数组ServletInputStream geetInputStream();// 得到请求体中一行的二进制流BufferedReader getReader();// 返回解码过了的请求体String getServerName();// 返回接收请求的服务器主机名int getServerPort();// 返回服务器接收此请求所用的端口号String getRemoteAddr();// 返回发送请求的客户端的IP地址String getRemoteHost();// 返回发送请求的客户端主机名String getRealPath();// 返回一个虚拟路径的真实路径String getCharacterEncoding();// 返回字符编码方式int geContentLength();// 返回请求体的长度 ( 字节数 )String getContentType();// 返回请求体的MIME类型String getProtocol();// 返回请求用的协议类型以及版本号String getScheme();// 返回请求用的协议名称( 例如 : http  https  ftp )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-response-对象"><a href="#2-response-对象" class="headerlink" title="2. response 对象 :"></a>2. response 对象 :</h2><blockquote><p>对象代表的是对客户端的响应 , 也就是说可以通过 response 对象来组织发送到客户端的数据 ; 但是由于组织方式比较底层 , 所以不建议初学者使用 , 需要向客户端发送文字时直接使用 ; 它是 HttpServletResponse 的实例 ; 作用域为 page ( 页面执行期 )</p></blockquote><h5 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">String getCharacterEncoding();// 返回响应用的是哪种字符编码ServletOutputStream getOutputStream();// 返回响应的一个二进制输出流PrintWriter getWriter();// 返回可以向客户端输出字符的一个对象void setContentLength(int len);// 设置响应头长度void setContentType(String type);// 设置响应的MIME类型void sendRedirect(String location);// 重新定向客户端的请求<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-session-对象"><a href="#3-session-对象" class="headerlink" title="3. session 对象 :"></a>3. session 对象 :</h2><blockquote><p>指的是客户端与服务器的一次会话 , 从客户连接到服务器的一个 WebApplication 开始 , 直到客户端与服务器断开连接为止 ; 它是 HTTPSession 类的实例 , 作用域为 session ( 会话期 )</p></blockquote><h5 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">long getCreationTime();// 返回SESSION创建时间 public String getId();// 返回SESSION创建时JSP引擎为它设的惟一ID号 long getLastAccessedTime();// 返回此SESSION里客户端最近一次请求时间 int getMaxInactiveInterval();// 返回两次请求间隔多长时间此SESSION被取消(ms) String[] getValueNames();// 返回一个包含此SESSION中所有可用属性的数组 void invalidate();// 取消SESSION，使SESSION不可用 boolean isNew();// 返回服务器创建的一个SESSION,客户端是否已经加入 void removeValue(String name);// 删除SESSION中指定的属性 void setMaxInactiveInterval();// 设置两次请求间隔多长时间此SESSION被取消(ms)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-out-对象"><a href="#4-out-对象" class="headerlink" title="4. out 对象 :"></a>4. out 对象 :</h2><blockquote><p>out 对象是 JspWriter 类的实例,是向客户端输出内容常用的对象 ; 作用域为 page ( 页面执行期 )</p></blockquote><h5 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">void clear();// 清除缓冲区的内容 void clearBuffer();// 清除缓冲区的当前内容 void flush();// 清空流 int getBufferSize();// 返回缓冲区以字节数的大小，如不设缓冲区则为0 int getRemaining();// 返回缓冲区还剩余多少可用 boolean isAutoFlush();// 返回缓冲区满时，是自动清空还是抛出异常 void close();// 关闭输出流 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-page-对象"><a href="#5-page-对象" class="headerlink" title="5. page 对象 :"></a>5. page 对象 :</h2><blockquote><p>page 对象就是指向当前 JSP 页面本身 , 有点象类中的 this 指针 , 它是 Object 类的实例 ; page 对象代表了正在运行的由 JSP 文件产生的类对象 , 不建议初学者使用 ; 作用域为 page ( 页面执行期 )</p></blockquote><h5 id="常用方法：-1"><a href="#常用方法：-1" class="headerlink" title="常用方法："></a>常用方法：</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">class getClass();// 返回此Object的类 int hashCode();// 返回此Object的hash码 boolean equals(Object obj);// 判断此Object是否与指定的Object对象相等 void copy(Object obj);// 把此Object拷贝到指定的Object对象中 Object clone();// 克隆此Object对象 String toString();// 把此Object对象转换成String类的对象 void notify();// 唤醒一个等待的线程 void notifyAll();// 唤醒所有等待的线程 void wait(int timeout);// 使一个线程处于等待直到timeout结束或被唤醒 void wait();// 使一个线程处于等待直到被唤醒 void enterMonitor();// 对Object加锁 void exitMonitor();// 对Object开锁<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-application-对象"><a href="#6-application-对象" class="headerlink" title="6. application 对象 :"></a>6. application 对象 :</h2><blockquote><p>实现了用户间数据的共享 , 可存放全局变量 ; 它开始于服务器的启动 , 直到服务器的关闭 , 在此期间 , 此对象将一直存在 ; 这样在用户的前后连接或不同用户之间的连接中 , 可以对此对象的同一属性进行操作 ; 在任何地方对此对象属性的操作 , 都将影响到其他用户对此的访问 ; 服务器的启动和关闭决定了 application 对象的生命 ; 它是 ServletContext 类的实例 ; 作用域为 application</p></blockquote><h5 id="常用方法：-2"><a href="#常用方法：-2" class="headerlink" title="常用方法："></a>常用方法：</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">Object getAttribute(String name);// 返回给定名的属性值 Enumeration getAttributeNames();// 返回所有可用属性名的枚举 void setAttribute(String name,Object obj);// 设定属性的属性值 void removeAttribute(String name);// 删除一属性及其属性值 String getServerInfo();// 返回JSP(SERVLET)引擎名及版本号 String getRealPath(String path);// 返回一虚拟路径的真实路径 ServletContext getContext(String uripath);// 返回指定WebApplication的application对象 int getMajorVersion();// 返回服务器支持的Servlet API的最大版本号 int getMinorVersion();// 返回服务器支持的Servlet API的最大版本号 String getMimeType(String file);// 返回指定文件的MIME类型 URL getResource(String path);// 返回指定资源(文件及目录)的URL路径 InputStream getResourceAsStream(String path);// 返回指定资源的输入流 RequestDispatcher getRequestDispatcher(String uripath);// 返回指定资源的RequestDispatcher对象Servlet getServlet(String name);// 返回指定名的ServletEnumeration getServlets();// 返回所有Servlet的枚举Enumeration getServletNames();// 返回所有Servlet名的枚举void log(String msg);// 把指定消息写入Servlet的日志文件void log(Exception exception,String msg);// 把指定异常的栈轨迹及错误消息写入Servlet的日志文件void log(String msg,Throwable throwable);// 把栈轨迹及给出的Throwable异常的说明信息 写入Servlet的日志文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-pageContext-对象"><a href="#7-pageContext-对象" class="headerlink" title="7. pageContext 对象 :"></a>7. pageContext 对象 :</h4><blockquote><p>提供了对 JSP 页面内所有的对象及名字空间的访问 , 也就是说他可以访问到本页所在的 session , 也可以取本页面所在的 application 的某一属性值 , 他相当于页面中所有功能的集大成者 , 它的本类名也叫 pageContext ; 作用域为 Pageconfig 对象</p></blockquote><h5 id="常用方法：-3"><a href="#常用方法：-3" class="headerlink" title="常用方法："></a>常用方法：</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">JspWriter getOut();// 返回当前客户端响应被使用的JspWriter流(out) HttpSession getSession();// 返回当前页中的HttpSession对象(session) Object getPage();// 返回当前页的Object对象(page) ServletRequest getRequest();// 返回当前页的ServletRequest对象(request) ServletResponse getResponse();// 返回当前页的ServletResponse对象(response) Exception getException();// 返回当前页的Exception对象(exception) ServletConfig getServletConfig();// 返回当前页的ServletConfig对象(config) ServletContext getServletContext();// 返回当前页的ServletContext对象(application)void setAttribute(String name,Object attribute);// 设置属性及属性值 void setAttribute(String name,Object obj,int scope);// 在指定范围内设置属性及属性值 public Object getAttribute(String name);// 取属性的值 Object getAttribute(String name,int scope);// 在指定范围内取属性的值 public Object findAttribute(String name);// 寻找一属性,返回起属性值或NULL void removeAttribute(String name);// 删除某属性 void removeAttribute(String name,int scope);// 在指定范围删除某属性 int getAttributeScope(String name);// 返回某属性的作用范围 Enumeration getAttributeNamesInScope(int scope);// 返回指定范围内可用的属性名枚举 void release();// 释放pageContext所占用的资源 void forward(String relativeUrlPath);// 使当前页面重导到另一页面 void include(String relativeUrlPath);// 在当前位置包含另一文件 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-config-对象"><a href="#8-config-对象" class="headerlink" title="8. config 对象 :"></a>8. config 对象 :</h2><blockquote><p>config 对象是在一个 Servlet 初始化时 , JSP 引擎向它传递信息用的 , 此信息包括 Servlet 初始化时所要用到的参数 ( 通过属性名和属性值构成 ) 以及服务器的有关信息 ( 通过传递一个 ServletContext 对象 ) ; 作用域为 page</p></blockquote><h5 id="常用方法：-4"><a href="#常用方法：-4" class="headerlink" title="常用方法："></a>常用方法：</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">ServletContext getServletContext();// 返回含有服务器相关信息的ServletContext对象 String getInitParameter(String name);// 返回初始化参数的值 Enumeration getInitParameterNames();// 返回Servlet初始化所需所有参数的枚举<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="9-exception-对象"><a href="#9-exception-对象" class="headerlink" title="9. exception 对象 :"></a>9. exception 对象 :</h4><blockquote><p>这是一个例外对象 , 当一个页面在运行过程中发生了例外 , 就产生这个对象 ; 如果一个JSP页面要应用此对象 , 就必须把 isErrorPage 设为true , 否则无法编译 ; 他实际上是 Throwable 的对象 ; 作用域为 page</p></blockquote><h5 id="常用方法：-5"><a href="#常用方法：-5" class="headerlink" title="常用方法："></a>常用方法：</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">String getMessage();// 返回描述异常的消息 String toString();// 返回关于异常的简短描述消息 void printStackTrace();// 显示异常及其栈轨迹 Throwable FillInStackTrace();// 重写异常的执行栈轨迹<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>对象名</th><th>描述</th><th>类型</th><th>作用域</th></tr></thead><tbody><tr><td>request</td><td>请求对象</td><td>javax.servlet.ServletRequest</td><td>Request</td></tr><tr><td>response</td><td>响应对象</td><td>javax.servlet.SrvletResponse</td><td>Page</td></tr><tr><td>pageContext</td><td>页面上下文对象</td><td>javax.servlet.jsp.PageContext</td><td>Page</td></tr><tr><td>session</td><td>会话对象</td><td>javax.servlet.http.HttpSession</td><td>Session</td></tr><tr><td>application</td><td>应用程序对象</td><td>javax.servlet.ServletContext</td><td>Application</td></tr><tr><td>out</td><td>输出对象</td><td>javax.servlet.jsp.JspWriter</td><td>Page</td></tr><tr><td>config</td><td>配置对象</td><td>javax.servlet.ServletConfig</td><td>Page</td></tr><tr><td>page</td><td>页面对象</td><td>javax.lang.Object</td><td>Page</td></tr><tr><td>exception</td><td>例外对象</td><td>javax.lang.Throwable</td><td>Page</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> jsp </category>
          
          <category> java基础 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jsp </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON</title>
      <link href="posts/5d92c8f1.html"/>
      <url>posts/5d92c8f1.html</url>
      
        <content type="html"><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="JSON-1"><a href="#JSON-1" class="headerlink" title="JSON"></a>JSON</h2><p>JSON: <strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation(JavaScript 对象表示法)</p><p>JSON 是存储和交换文本信息的语法。类似 XML。</p><p>JSON 比 XML 更小、更快，更易解析。</p><p>JSON是一种轻量级的数据交换格式。</p><p>它基于ECMAScript(欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。</p><p>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><h2 id="JSON-实例"><a href="#JSON-实例" class="headerlink" title="JSON 实例"></a>JSON 实例</h2><p>简单地说，JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式，例如在 PHP 中，可以将 JSON 还原为数组或者一个基本对象。在用到AJAX时，如果需要用到数组传值，这时就需要用JSON将数组转化为字符串。</p><h3 id="表示对象"><a href="#表示对象" class="headerlink" title="表示对象"></a>表示对象</h3><p>对象是一个无序的“‘名称/值’对”集合。一个对象以{左括号开始，}右括号结束。每个“名称”后跟一个:冒号；“‘名称/值’ 对”之间使用,逗号分隔。</p><pre class="line-numbers language-none"><code class="language-none">{"firstName": "Brett", "lastName": "McLaughlin"}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="表示数组"><a href="#表示数组" class="headerlink" title="表示数组"></a>表示数组</h3><p>和普通的 JS 数组一样，JSON 表示数组的方式也是使用方括号 []。</p><pre class="line-numbers language-none"><code class="language-none">{    "people":[        {            "firstName": "Brett",            "lastName":"McLaughlin"        },        {            "firstName":"Jason",            "lastName":"Hunter"        }    ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这不难理解。在这个示例中，只有一个名为 people的变量，值是包含两个条目的数组，每个条目是一个人的记录，其中包含名和姓。上面的示例演示如何用括号将记录组合成一个值。当然，可以使用相同的语法表示更过多的值（每个值包含多个记录）。</p><p>在处理 JSON 格式的数据时，没有需要遵守的预定义的约束。所以，在同样的数据结构中，可以改变表示数据的方式，也可以使用不同方式表示同一事物。</p><p>如前面所说，除了对象和数组，你也可以简单地使用字符串或者数字等来存储简单的数据，但这样并没有多大意义。</p><h2 id="什么是-JSON-？"><a href="#什么是-JSON-？" class="headerlink" title="什么是 JSON ？"></a>什么是 JSON ？</h2><ul><li>JSON 指的是 JavaScript 对象表示法（<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation）</li><li>JSON 是轻量级的文本数据交换格式</li><li>JSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。</li><li>JSON 具有自我描述性，更易理解</li></ul><h2 id="JSON-语法规则"><a href="#JSON-语法规则" class="headerlink" title="JSON 语法规则"></a>JSON 语法规则</h2><p>JSON是一个标记符的序列。这套标记符包含六个构造字符、字符串、数字和三个字面名。 JSON是一个序列化的对象或数组。</p><h3 id="1-六个构造字符："><a href="#1-六个构造字符：" class="headerlink" title="1. 六个构造字符："></a>1. 六个构造字符：</h3><pre class="line-numbers language-none"><code class="language-none">begin-array = ws %x5B ws ; [ 左方括号begin-object = ws %x7B ws ; { 左大括号end-array = ws %x5D ws ; ] 右方括号end-object = ws %x7D ws ; } 右大括号name-separator = ws %x3A ws ; : 冒号value-separator = ws %x2C ws ; , 逗号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-在这六个构造字符的前或后允许存在无意义的空白符-ws"><a href="#2-在这六个构造字符的前或后允许存在无意义的空白符-ws" class="headerlink" title="2. 在这六个构造字符的前或后允许存在无意义的空白符(ws):"></a>2. 在这六个构造字符的前或后允许存在无意义的空白符(ws):</h3><pre class="line-numbers language-none"><code class="language-none">ws = *（%x20 /; 空间%x09 /; 水平标签%x0A /; 换行或换行%x0D）; 回程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-JSON的值"><a href="#3-JSON的值" class="headerlink" title="3.JSON的值:"></a>3.JSON的值:</h3><p>3.1 JSON的构成: ws 值 ws</p><p>3.2值可以是对象、数组、数字、字符串或者三个字面值(false、null、true)中的一个。值中的字面值中的英文必须使用小写。</p><p>3.2.1对象由花括号括起来的逗号分割的成员构成，成员是字符串键和上文所述的值由逗号分割的键值对组成，如：</p><pre class="line-numbers language-none"><code class="language-none">{    "name": "John Doe",     "age": 18,     "address": {        "country" : "china",         "zip-code": "10000"    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.2.2数组是由方括号括起来的一组值构成，如：</p><pre class="line-numbers language-none"><code class="language-none">[3, 1, 4, 1, 5, 9, 2, 6]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.2.3 字符串与C或者Java的字符串非常相似。字符串是由双引号包围的任意数量Unicode字符的集合，使用反斜线转义。一个字符（character）即一个单独的字符串（character string）。</p><p>3.2.4数字也与C或者Java的数值非常相似。除去未曾使用的八进制与十六进制格式。除去一些编码细节。 [2] 一些合法的JSON的实例：</p><pre class="line-numbers language-none"><code class="language-none">{"a": 1, "b": [1, 2, 3]}[1, 2, "3", {"a": 4}]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="JSON-与-JS-对象的关系"><a href="#JSON-与-JS-对象的关系" class="headerlink" title="JSON 与 JS 对象的关系"></a>JSON 与 JS 对象的关系</h2><p>很多人搞不清楚 JSON 和 JS 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 如</p><pre class="line-numbers language-none"><code class="language-none">var obj = {    a: 'Hello',     b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的var json = '{"a": "Hello", "b": "World"}'; //这是一个 JSON 字符串，本质是一个字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="JSON-和-JS-对象互转"><a href="#JSON-和-JS-对象互转" class="headerlink" title="JSON 和 JS 对象互转"></a>JSON 和 JS 对象互转</h2><p>要实现从JSON字符串转换为JS对象，使用 JSON.parse() 方法：</p><pre class="line-numbers language-none"><code class="language-none">var obj = {    a: 'Hello',     b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>要实现从JS对象转换为JSON字符串，使用 JSON.stringify() 方法：</p><pre class="line-numbers language-none"><code class="language-none">var json = JSON.stringify({a: 'Hello', b: 'World'}); //结果是 '{"a": "Hello", "b": "World"}'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="常用类型编辑"><a href="#常用类型编辑" class="headerlink" title="常用类型编辑"></a>常用类型编辑</h2><p>任何支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。但是对象和数组是比较特殊且常用的两种类型。</p><p><strong>对象</strong>：对象在 JS 中是使用花括号包裹 {} 起来的内容，数据结构为 {key1：value1, key2：value2, …} 的键值对结构。在面向对象的语言中，key 为对象的属性，value 为对应的值。键名可以使用整数和字符串来表示。值的类型可以是任意类型。</p><p><strong>数组</strong>：数组在 JS 中是方括号 [] 包裹起来的内容，数据结构为 [“java”, “javascript”, “vb”, …] 的索引结构。在 JS 中，数组是一种比较特殊的数据类型，它也可以像对象那样使用键值对，但还是索引使用得多。同样，值的类型可以是任意类型</p><hr><h1 id="JSON-简介"><a href="#JSON-简介" class="headerlink" title="JSON 简介"></a>JSON 简介</h1><h2 id="JSON-简介-1"><a href="#JSON-简介-1" class="headerlink" title="JSON - 简介"></a>JSON - 简介</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;前端教程&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;JavaScript 创建 JSON 对象&lt;/h2&gt;&lt;p&gt;网站名称: &lt;span id="jname"&gt;&lt;/span&gt;&lt;br /&gt; 网站地址: &lt;span id="jurl"&gt;&lt;/span&gt;&lt;br /&gt; 网站 slogan: &lt;span id="jslogan"&gt;&lt;/span&gt;&lt;br /&gt; &lt;/p&gt;&lt;script&gt;var JSONObject= {    "name":"前端教程",    "url":"www.baidu.com",     "slogan":"一个助你成为全栈开发的网站"};document.getElementById("jname").innerHTML=JSONObject.name document.getElementById("jurl").innerHTML=JSONObject.url document.getElementById("jslogan").innerHTML=JSONObject.slogan&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="与-XML-相同之处"><a href="#与-XML-相同之处" class="headerlink" title="与 XML 相同之处"></a>与 XML 相同之处</h2><ul><li>JSON 是纯文本</li><li>JSON 具有”自我描述性”（人类可读）</li><li>JSON 具有层级结构（值中存在值）</li><li>JSON 可通过 JavaScript 进行解析</li><li>JSON 数据可使用 AJAX 进行传输</li></ul><h2 id="与-XML-不同之处"><a href="#与-XML-不同之处" class="headerlink" title="与 XML 不同之处"></a>与 XML 不同之处</h2><ul><li>没有结束标签</li><li>更短</li><li>读写的速度更快</li><li>能够使用内建的 JavaScript eval() 方法进行解析</li><li>使用数组</li><li>不使用保留字</li></ul><h2 id="为什么使用-JSON？"><a href="#为什么使用-JSON？" class="headerlink" title="为什么使用 JSON？"></a>为什么使用 JSON？</h2><p>对于 AJAX 应用程序来说，JSON 比 XML 更快更易使用：</p><h3 id="使用-XML"><a href="#使用-XML" class="headerlink" title="使用 XML"></a>使用 XML</h3><ul><li>读取 XML 文档</li><li>使用 XML DOM 来循环遍历文档</li><li>读取值并存储在变量中</li></ul><h3 id="使用-JSON"><a href="#使用-JSON" class="headerlink" title="使用 JSON"></a>使用 JSON</h3><ul><li>读取 JSON 字符串</li><li>用 eval() 处理 JSON 字符串</li></ul><hr><h1 id="JSON-语法"><a href="#JSON-语法" class="headerlink" title="JSON 语法"></a>JSON 语法</h1><h2 id="JSON-语法-1"><a href="#JSON-语法-1" class="headerlink" title="JSON 语法"></a>JSON 语法</h2><p>JSON 语法是 JavaScript 语法的子集。</p><h2 id="JSON-语法规则-1"><a href="#JSON-语法规则-1" class="headerlink" title="JSON 语法规则"></a>JSON 语法规则</h2><p>JSON 语法是 JavaScript 对象表示语法的子集。</p><ul><li>数据在名称/值对中</li><li>数据由逗号分隔</li><li>大括号保存对象</li><li>中括号保存数组</li></ul><h2 id="JSON-名称-值对"><a href="#JSON-名称-值对" class="headerlink" title="JSON 名称/值对"></a>JSON 名称/值对</h2><p>JSON 数据的书写格式是：名称/值对。</p><p>名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值：</p><pre class="line-numbers language-none"><code class="language-none">"name" : "前端教程"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这很容易理解，等价于这条 JavaScript 语句：</p><pre class="line-numbers language-none"><code class="language-none">name = "前端教程"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="JSON-值"><a href="#JSON-值" class="headerlink" title="JSON 值"></a>JSON 值</h2><p>JSON 值可以是：</p><ul><li>数字（整数或浮点数）</li><li>字符串（在双引号中）</li><li>逻辑值（true 或 false）</li><li>数组（在中括号中）</li><li>对象（在大括号中）</li><li>null</li></ul><h2 id="JSON-数字"><a href="#JSON-数字" class="headerlink" title="JSON 数字"></a>JSON 数字</h2><p>JSON 数字可以是整型或者浮点型：</p><pre class="line-numbers language-none"><code class="language-none">{  "age":30  }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h2><p>JSON 对象在大括号（{}）中书写：</p><p>对象可以包含多个名称/值对：</p><pre class="line-numbers language-none"><code class="language-none">{  "name":"前端教程" , "url":"www.baidu.com"  }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一点也容易理解，与这条 JavaScript 语句等价：</p><pre class="line-numbers language-none"><code class="language-none">name = "前端教程"  url = "www.baidu.com"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="JSON-数组"><a href="#JSON-数组" class="headerlink" title="JSON 数组"></a>JSON 数组</h2><p>JSON 数组在中括号中书写：</p><p>数组可包含多个对象：</p><pre class="line-numbers language-none"><code class="language-none">{    "sites": [        { "name":"前端教程" , "url":"www.baidu.com" },         { "name":"google" , "url":"www.google.com" },         { "name":"微博" , "url":"www.weibo.com" }    ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的例子中，对象 “sites” 是包含三个对象的数组。每个对象代表一条关于某个网站（name、url）的记录。</p><h2 id="JSON-布尔值"><a href="#JSON-布尔值" class="headerlink" title="JSON 布尔值"></a>JSON 布尔值</h2><p>JSON 布尔值可以是 true 或者 false：</p><pre class="line-numbers language-none"><code class="language-none">{ "flag":true }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="JSON-null"><a href="#JSON-null" class="headerlink" title="JSON null"></a>JSON null</h2><p>JSON 可以设置 null 值：</p><pre class="line-numbers language-none"><code class="language-none">{ "axihe":null }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="JSON-使用-JavaScript-语法"><a href="#JSON-使用-JavaScript-语法" class="headerlink" title="JSON 使用 JavaScript 语法"></a>JSON 使用 JavaScript 语法</h2><p>因为 JSON 使用 JavaScript 语法，所以无需额外的软件就能处理 JavaScript 中的 JSON。</p><p>通过 JavaScript，您可以创建一个对象数组，并像这样进行赋值：</p><pre class="line-numbers language-none"><code class="language-none">var sites = [    { "name":"baidu" , "url":"www.baidu.com" },     { "name":"google" , "url":"www.google.com" },     { "name":"微博" , "url":"www.weibo.com" }];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以像这样访问 JavaScript 对象数组中的第一项（索引从 0 开始）：</p><pre class="line-numbers language-none"><code class="language-none">sites[0].name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回的内容是：</p><pre class="line-numbers language-none"><code class="language-none">axihe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以像这样修改数据：</p><pre class="line-numbers language-none"><code class="language-none">sites[0].name="前端教程";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如何把 JSON 文本转换为 JavaScript 对象。</p><h2 id="JSON-文件"><a href="#JSON-文件" class="headerlink" title="JSON 文件"></a>JSON 文件</h2><ul><li>JSON 文件的文件类型是 “.json”</li><li>JSON 文本的 MIME 类型是 “application/json”</li></ul><hr><h1 id="JSON-对象-1"><a href="#JSON-对象-1" class="headerlink" title="JSON 对象"></a>JSON 对象</h1><h2 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h2><pre class="line-numbers language-none"><code class="language-none">{     "name":"baidu",     "alexa":10000,     "site":null }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JSON 对象使用在大括号({})中书写。</p><p>对象可以包含多个 <strong>key/value（键/值）</strong>对。</p><p>key 必须是字符串，value 可以是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。</p><p>key 和 value 中使用冒号(:)分割。</p><p>每个 key/value 对使用逗号(,)分割。</p><h2 id="访问对象值"><a href="#访问对象值" class="headerlink" title="访问对象值"></a>访问对象值</h2><p>你可以使用点号（.）来访问对象的值：</p><pre class="line-numbers language-none"><code class="language-none">var myObj, x;myObj = { "name":"baidu", "alexa":10000, "site":null };x = myObj.name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>你也可以使用中括号（[]）来访问对象的值：</p><pre class="line-numbers language-none"><code class="language-none">var myObj, x;myObj = { "name":"baidu", "alexa":10000, "site":null };x = myObj["name"];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="循环对象"><a href="#循环对象" class="headerlink" title="循环对象"></a>循环对象</h2><p>你可以使用 for-in 来循环对象的属性：</p><pre class="line-numbers language-none"><code class="language-none">var myObj, x;myObj = { "name":"baidu", "alexa":10000, "site":null };x = myObj.name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在 for-in 循环对象的属性时，使用中括号（[]）来访问属性的值：</p><pre class="line-numbers language-none"><code class="language-none">var myObj = { "name":"baidu", "alexa":10000, "site":null };for (x in myObj) {    document.getElementById("demo").innerHTML += myObj[x] + "&lt;br&gt;";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="嵌套-JSON-对象"><a href="#嵌套-JSON-对象" class="headerlink" title="嵌套 JSON 对象"></a>嵌套 JSON 对象</h2><p>JSON 对象中可以包含另外一个 JSON 对象：</p><pre class="line-numbers language-none"><code class="language-none">myObj = {    "name":"",baidu    "alexa":10000,    "sites": {        "site1":"www.baidu.com",        "site2":"m.baidu.com",        "site3":"c.baidu.com"    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以使用点号(.)或者中括号([])来访问嵌套的 JSON 对象。</p><pre class="line-numbers language-none"><code class="language-none">x = myObj.sites.site1;// 或者x = myObj.sites["site1"];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="修改值"><a href="#修改值" class="headerlink" title="修改值"></a>修改值</h2><p>你可以使用点号(.)来修改 JSON 对象的值：</p><pre class="line-numbers language-none"><code class="language-none">myObj.sites.site1 = "www.google.com";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你可以使用中括号([])来修改 JSON 对象的值：</p><pre class="line-numbers language-none"><code class="language-none">myObj.sites["site1"] = "www.google.com";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="删除对象属性"><a href="#删除对象属性" class="headerlink" title="删除对象属性"></a>删除对象属性</h2><p>我们可以使用 <strong>delete</strong> 关键字来删除 JSON 对象的属性：</p><pre class="line-numbers language-none"><code class="language-none">delete myObj.sites.site1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你可以使用中括号([])来删除 JSON 对象的属性：</p><pre class="line-numbers language-none"><code class="language-none">delete myObj.sites["site1"]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h1 id="JSON-数组-1"><a href="#JSON-数组-1" class="headerlink" title="JSON 数组"></a>JSON 数组</h1><h2 id="数组作为-JSON-对象"><a href="#数组作为-JSON-对象" class="headerlink" title="数组作为 JSON 对象"></a>数组作为 JSON 对象</h2><pre class="line-numbers language-none"><code class="language-none">[ "Google", "baidu", "Taobao" ]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>JSON 数组在中括号中书写。</p><p>JSON 中数组值必须是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。</p><p>JavaScript 中，数组值可以是以上的 JSON 数据类型，也可以是 JavaScript 的表达式，包括函数，日期，及 _undefined_。</p><h2 id="JSON-对象中的数组"><a href="#JSON-对象中的数组" class="headerlink" title="JSON 对象中的数组"></a>JSON 对象中的数组</h2><p>对象属性的值可以是一个数组：</p><pre class="line-numbers language-none"><code class="language-none">{    "name":"网站",    "num":3,    "sites":[ "Google", "baidu", "Taobao" ]}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以使用索引值来访问数组：</p><pre class="line-numbers language-none"><code class="language-none">x = myObj.sites[0];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="循环数组"><a href="#循环数组" class="headerlink" title="循环数组"></a>循环数组</h2><p>你可以使用 for-in 来访问数组：</p><pre class="line-numbers language-none"><code class="language-none">for (i in myObj.sites) {    x += myObj.sites[i] + "&lt;br&gt;";}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你也可以使用 for 循环：</p><pre class="line-numbers language-none"><code class="language-none">for (i = 0; i &lt; myObj.sites.length; i++) {    x += myObj.sites[i] + "&lt;br&gt;";}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="嵌套-JSON-对象中的数组"><a href="#嵌套-JSON-对象中的数组" class="headerlink" title="嵌套 JSON 对象中的数组"></a>嵌套 JSON 对象中的数组</h2><p>JSON 对象中数组可以包含另外一个数组，或者另外一个 JSON 对象：</p><pre class="line-numbers language-none"><code class="language-none">myObj = {    "name":"网站",    "num":3,    "sites": [        { "name":"Google", "info":[ "Android", "Google 搜索", "Google 翻译" ] },        { "name":"axihe", "info":[ "前端", "工具", "微信" ] },        { "name":"Taobao", "info":[ "淘宝", "网购" ] }    ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以使用 for-in 来循环访问每个数组：</p><pre class="line-numbers language-none"><code class="language-none">for (i in myObj.sites) {    x += "&lt;h1&gt;" + myObj.sites[i].name + "&lt;/h1&gt;";    for (j in myObj.sites[i].info) {        x += myObj.sites[i].info[j] + "&lt;br&gt;";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改数组值"><a href="#修改数组值" class="headerlink" title="修改数组值"></a>修改数组值</h2><p>你可以使用索引值来修改数组值：</p><pre class="line-numbers language-none"><code class="language-none">myObj.sites[1] = "Github";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="删除数组元素"><a href="#删除数组元素" class="headerlink" title="删除数组元素"></a>删除数组元素</h2><p>我们可以使用 <strong>delete</strong> 关键字来删除数组元素：</p><pre class="line-numbers language-none"><code class="language-none">delete myObj.sites[1];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h1 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h1><h2 id="JSON-parse-1"><a href="#JSON-parse-1" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h2><p>JSON 通常用于与服务端交换数据。</p><p>在接收服务器数据时一般是字符串。</p><p>我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">JSON.parse(text[, reviver])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>参数说明：</strong></p><ul><li>**text:**必需， 一个有效的 JSON 字符串。</li><li><strong>reviver:</strong> 可选，一个转换结果的函数， 将为对象的每个成员调用此函数。</li></ul><h2 id="JSON-解析实例"><a href="#JSON-解析实例" class="headerlink" title="JSON 解析实例"></a>JSON 解析实例</h2><p>例如我们从服务器接收了以下数据：</p><pre class="line-numbers language-none"><code class="language-none">{ "name":"baidu", "alexa":10000, "site":"www.baidu.com" }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们使用 JSON.parse() 方法处理以上数据，将其转换为 JavaScript 对象：</p><pre class="line-numbers language-none"><code class="language-none">var obj = JSON.parse('{ "name":"baidu", "alexa":10000, "site":"www.baidu.com" }');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解析完成后，我们就可以在网页上使用 JSON 数据了：</p><pre class="line-numbers language-none"><code class="language-none">&lt;p id="demo"&gt;&lt;/p&gt; &lt;script&gt;var obj = JSON.parse('{ "name":"baidu", "alexa":10000, "site":"www.baidu.com" }');document.getElementById("demo").innerHTML = obj.name + "：" + obj.site;&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="从服务端接收-JSON-数据"><a href="#从服务端接收-JSON-数据" class="headerlink" title="从服务端接收 JSON 数据"></a>从服务端接收 JSON 数据</h2><p>我们可以使用 AJAX 从服务器请求 JSON 数据，并解析为 JavaScript 对象。</p><pre class="line-numbers language-none"><code class="language-none">var xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange = function() {    if (this.readyState ** 4 &amp;&amp; this.status ** 200) {        myObj = JSON.parse(this.responseText);        document.getElementById("demo").innerHTML = myObj.name;    }};xmlhttp.open("GET", "/try/ajax/json_demo.txt", true);xmlhttp.send();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="从服务端接收数组的-JSON-数据"><a href="#从服务端接收数组的-JSON-数据" class="headerlink" title="从服务端接收数组的 JSON 数据"></a>从服务端接收数组的 JSON 数据</h2><p>如果从服务端接收的是数组的 JSON 数据，则 JSON.parse 会将其转换为 JavaScript 数组：</p><pre class="line-numbers language-none"><code class="language-none">var xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange = function() {    if (this.readyState ** 4 &amp;&amp; this.status ** 200) {        myArr = JSON.parse(this.responseText);        document.getElementById("demo").innerHTML = myArr[1];    }};xmlhttp.open("GET", "/try/ajax/json_demo_array.txt", true);xmlhttp.send();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h3><p>JSON 不能存储 Date 对象。</p><p>如果你需要存储 Date 对象，需要将其转换为字符串。</p><p>之后再将字符串转换为 Date 对象。</p><pre class="line-numbers language-none"><code class="language-none">var text = '{ "name":"axihe", "initDate":"2013-12-14", "site":"www.axihe.com"}';var obj = JSON.parse(text);obj.initDate = new Date(obj.initDate); document.getElementById("demo").innerHTML = obj.name + "创建日期: " + obj.initDate;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以启用 JSON.parse 的第二个参数 reviver，一个转换结果的函数，对象的每个成员调用此函数。</p><pre class="line-numbers language-none"><code class="language-none">var text = '{ "name":"axihe", "initDate":"2013-12-14", "site":"www.axihe.com"}';var obj = JSON.parse(text, function (key, value) {    if (key ** "initDate") {        return new Date(value);    } else {        return value;} }); document.getElementById("demo").innerHTML = obj.name + "创建日期：" + obj.initDate;var text = '{ "name":"axihe", "initDate":"2013-12-14", "site":"www.axihe.com"}';var obj = JSON.parse(text, function (key, value) {    if (key ** "initDate") {        return new Date(value);    } else {        return value;} }); document.getElementById("demo").innerHTML = obj.name + "创建日期：" + obj.initDate;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="解析函数"><a href="#解析函数" class="headerlink" title="解析函数"></a>解析函数</h2><p>JSON 不允许包含函数，但你可以将函数作为字符串存储，之后再将字符串转换为函数。</p><pre class="line-numbers language-none"><code class="language-none">var text = '{ "name":"axihe", "alexa":"function () {return 10000;}", "site":"www.axihe.com"}';var obj = JSON.parse(text);obj.alexa = eval("(" + obj.alexa + ")"); document.getElementById("demo").innerHTML = obj.name + " Alexa 排名：" + obj.alexa();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不建议在 JSON 中使用函数。</p><h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>主流浏览器都支持 JSON.parse() 函数：</p><ul><li>Firefox 3.5</li><li>Internet Explorer 8</li><li>Chrome</li><li>Opera 10</li><li>Safari 4</li></ul><hr><h1 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h1><h2 id="JSON-stringify-1"><a href="#JSON-stringify-1" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h2><p>JSON 通常用于与服务端交换数据。</p><p>在向服务器发送数据时一般是字符串。</p><p>我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">JSON.stringify(value[, replacer[, space]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>参数说明：</strong></p><ul><li><p><strong>value:</strong></p><p>必需， 要转换的 JavaScript 值（通常为对象或数组）。</p></li><li><p><strong>replacer:</strong></p><p>可选。用于转换结果的函数或数组。</p><p>如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：”“。</p><p>如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当 value 参数也为数组时，将忽略 replacer 数组。</p></li><li><p><strong>space:</strong></p><p>可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 也可以使用非数字，如：\t。</p></li></ul><h2 id="JavaScript-对象转换"><a href="#JavaScript-对象转换" class="headerlink" title="JavaScript 对象转换"></a>JavaScript 对象转换</h2><p>例如我们向服务器发送以下数据：</p><pre class="line-numbers language-none"><code class="language-none">var obj = { "name":"baidu", "alexa":10000, "site":"www.baidu.com"};<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们使用 JSON.stringify() 方法处理以上数据，将其转换为字符串：</p><pre class="line-numbers language-none"><code class="language-none">var myJSON = JSON.stringify(obj);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>myJSON 为字符串。</p><p>我们可以将 myJSON 发送到服务器：</p><pre class="line-numbers language-none"><code class="language-none">var obj = { "name":"axihe", "alexa":10000, "site":"www.axihe.com"};var myJSON = JSON.stringify(obj);document.getElementById("demo").innerHTML = myJSON;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="JavaScript-数组转换"><a href="#JavaScript-数组转换" class="headerlink" title="JavaScript 数组转换"></a>JavaScript 数组转换</h2><p>我们也可以将 JavaScript 数组转换为 JSON 字符串：</p><pre class="line-numbers language-none"><code class="language-none">var arr = [ "Google", "axihe", "Taobao", "Facebook" ];var myJSON = JSON.stringify(arr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>myJSON 为字符串。</p><p>我们可以将 myJSON 发送到服务器：</p><pre class="line-numbers language-none"><code class="language-none">var arr = [ "Google", "axihe", "Taobao", "Facebook" ];var myJSON = JSON.stringify(arr);document.getElementById("demo").innerHTML = myJSON;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h2><h3 id="解析数据-1"><a href="#解析数据-1" class="headerlink" title="解析数据"></a>解析数据</h3><p>JSON 不能存储 Date 对象。</p><p>JSON.stringify() 会将所有日期转换为字符串。</p><pre class="line-numbers language-none"><code class="language-none">var obj = { "name":"baidu", "initDate":new Date(), "site":"www.baidu.com"};var myJSON = JSON.stringify(obj);document.getElementById("demo").innerHTML = myJSON;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>之后你可以再将字符串转换为 Date 对象。</p><h2 id="解析函数-1"><a href="#解析函数-1" class="headerlink" title="解析函数"></a>解析函数</h2><p>JSON 不允许包含函数，JSON.stringify() 会删除 JavaScript 对象的函数，包括 key 和 value。</p><pre class="line-numbers language-none"><code class="language-none">var obj = { "name":"baidu", "alexa":function () {return 10000;}, "site":"www.baidu.com"};var myJSON = JSON.stringify(obj); document.getElementById("demo").innerHTML = myJSON;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以在执行 JSON.stringify() 函数前将函数转换为字符串来避免以上问题的发生：</p><pre class="line-numbers language-none"><code class="language-none">var obj = { "name":"baidu", "alexa":function () {return 10000;}, "site":"www.baidu.com"};obj.alexa = obj.alexa.toString();var myJSON = JSON.stringify(obj); document.getElementById("demo").innerHTML = myJSON;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不建议在 JSON 中使用函数。</p><h2 id="浏览器支持-1"><a href="#浏览器支持-1" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>主流浏览器都支持 JSON.stringify() 函数：</p><ul><li>Firefox 3.5</li><li>Internet Explorer 8</li><li>Chrome</li><li>Opera 10</li><li>Safari 4</li></ul><hr><h1 id="JSON-使用"><a href="#JSON-使用" class="headerlink" title="JSON 使用"></a>JSON 使用</h1><h2 id="把-JSON-文本转换为-JavaScript-对象"><a href="#把-JSON-文本转换为-JavaScript-对象" class="headerlink" title="把 JSON 文本转换为 JavaScript 对象"></a>把 JSON 文本转换为 JavaScript 对象</h2><p>JSON 最常见的用法之一，是从 web 服务器上读取 JSON 数据（作为文件或作为 HttpRequest），将 JSON 数据转换为 JavaScript 对象，然后在网页中使用该数据。</p><p>为了更简单地为您讲解，我们使用字符串作为输入进行演示（而不是文件）。</p><h2 id="JSON-实例-来自字符串的对象"><a href="#JSON-实例-来自字符串的对象" class="headerlink" title="JSON 实例 - 来自字符串的对象"></a>JSON 实例 - 来自字符串的对象</h2><p>创建包含 JSON 语法的 JavaScript 字符串：</p><pre class="line-numbers language-none"><code class="language-none">var txt = '{ "sites" : [' +'{ "name":"前端教程" , "url":"www.xxx.com" },' +'{ "name":"google" , "url":"www.google.com" },' +'{ "name":"微博" , "url":"www.weibo.com" } ]}';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于 JSON 语法是 JavaScript 语法的子集，JavaScript 函数 eval() 可用于将 JSON 文本转换为 JavaScript 对象。</p><p>eval() 函数使用的是 JavaScript 编译器，可解析 JSON 文本，然后生成 JavaScript 对象。必须把文本包围在括号中，这样才能避免语法错误：</p><pre class="line-numbers language-none"><code class="language-none">var obj = eval ("(" + txt + ")");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在网页中使用 JavaScript 对象：</p><pre class="line-numbers language-none"><code class="language-none">var txt = '{ "sites" : [' +'{ "name":"xxx" , "url":"www.xxx.com" },' +'{ "name":"google" , "url":"www.google.com" },' +'{ "name":"微博" , "url":"www.weibo.com" } ]}'; var obj = eval ("(" + txt + ")"); document.getElementById("name").innerHTML=obj.sites[0].name document.getElementById("url").innerHTML=obj.sites[0].url<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="JSON-解析器"><a href="#JSON-解析器" class="headerlink" title="JSON 解析器"></a>JSON 解析器</h2><p>函数可编译并执行任何 JavaScript 代码。这隐藏了一个潜在的安全问题。</p><p>使用 JSON 解析器将 JSON 转换为 JavaScript 对象是更安全的做法。JSON 解析器只能识别 JSON 文本，而不会编译脚本。</p><p>在浏览器中，这提供了原生的 JSON 支持，而且 JSON 解析器的速度更快。</p><p>较新的浏览器和最新的 ECMAScript (JavaScript) 标准中均包含了原生的对 JSON 的支持。</p><table><thead><tr><th align="left">Web 浏览器支持</th><th align="left">Web 软件支持</th></tr></thead><tbody><tr><td align="left">Firefox (Mozilla) 3.5Internet Explorer 8ChromeOpera 10Safari 4</td><td align="left">jQueryYahoo UIPrototypeDojoECMAScript 1.5</td></tr></tbody></table><p>对于较老的浏览器，可使用 JavaScript 库： <a href="https://github.com/douglascrockford/JSON-js">https://github.com/douglascrockford/JSON-js</a></p><p>JSON 格式最初是 <a href="http://developer.yahoo.com/yui/theater/video.php?v=crockford-json">originally specified by Douglas Crockford</a></p><p>Jsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。</p><p>为什么我们从不同的域（网站）访问数据需要一个特殊的技术( JSONP )呢？这是因为同源策略。</p><p>同源策略，它是由 Netscape 提出的一个著名的安全策略，现在所有支持 JavaScript 的浏览器都会使用这个策略。</p><h2 id="JSONP-应用"><a href="#JSONP-应用" class="headerlink" title="JSONP 应用"></a>JSONP 应用</h2><h3 id="1-服务端-JSONP-格式数据"><a href="#1-服务端-JSONP-格式数据" class="headerlink" title="1. 服务端 JSONP 格式数据"></a>1. 服务端 JSONP 格式数据</h3><p>如客户想访问 : <strong>/jsonp.php?jsoncallback=callbackFunction</strong>。</p><p>假设客户期望返回数据：<code>["customername1","customername2"]</code>。</p><p>真正返回到客户端的数据显示为: <code>callbackFunction(["customername1","customername2"])</code>。</p><p>服务端文件 jsonp.php 代码为：</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php    header('Content-type: application/json');    //获取回调函数名    $jsoncallback = htmlspecialchars($_REQUEST ['jsoncallback']);    //json数据    $json_data = '["customername1","customername2"]';    //输出jsonp格式的数据    echo $jsoncallback . "(" . $json_data . ")";?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-客户端实现-callbackFunction-函数"><a href="#2-客户端实现-callbackFunction-函数" class="headerlink" title="2. 客户端实现 callbackFunction 函数"></a>2. 客户端实现 callbackFunction 函数</h3><pre class="line-numbers language-none"><code class="language-none">&lt;script type="text/javascript"&gt;function callbackFunction(result, methodName){    var html = '&lt;ul&gt;';    for(var i = 0; i &lt; result.length; i++)    {        html += '&lt;li&gt;' + result[i] + '&lt;/li&gt;';    }    html += '&lt;/ul&gt;';    document.getElementById('divCustomers').innerHTML = html;}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="页面展示"><a href="#页面展示" class="headerlink" title="页面展示"></a>页面展示</h3><pre class="line-numbers language-none"><code class="language-none">&lt;div id="divCustomers"&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="客户端页面完整代码"><a href="#客户端页面完整代码" class="headerlink" title="客户端页面完整代码"></a>客户端页面完整代码</h3><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;JSONP 实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="divCustomers"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;function callbackFunction(result, methodName){    var html = '&lt;ul&gt;';    for(var i = 0; i &lt; result.length; i++)    {        html += '&lt;li&gt;' + result[i] + '&lt;/li&gt;';    }    html += '&lt;/ul&gt;';    document.getElementById('divCustomers').innerHTML = html;}&lt;/script&gt;&lt;script type="text/javascript" src="/jsonp.php?jsoncallback=callbackFunction"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="jQuery-使用-JSONP"><a href="#jQuery-使用-JSONP" class="headerlink" title="jQuery 使用 JSONP"></a>jQuery 使用 JSONP</h2><p>以上代码可以使用 jQuery 代码实例：</p><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset="utf-8"&gt;    &lt;title&gt;JSONP 实例&lt;/title&gt;    &lt;script src="/libs/jquery/1.8.3/jquery.js"&gt;&lt;/script&gt;    &lt;/head&gt;&lt;body&gt;&lt;div id="divCustomers"&gt;&lt;/div&gt;&lt;script&gt;$.getJSON("/jsonp.php?jsoncallback=?", function(data) {        var html = '&lt;ul&gt;';    for(var i = 0; i &lt; data.length; i++)    {        html += '&lt;li&gt;' + data[i] + '&lt;/li&gt;';    }    html += '&lt;/ul&gt;';        $('#divCustomers').html(html); });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> json </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端提升必备</title>
      <link href="posts/890c8c12.html"/>
      <url>posts/890c8c12.html</url>
      
        <content type="html"><![CDATA[<h1 id="前端提升"><a href="#前端提升" class="headerlink" title="前端提升"></a>前端提升</h1><h2 id="常用编辑器"><a href="#常用编辑器" class="headerlink" title="常用编辑器"></a>常用编辑器</h2><ul><li>Notepad++：<a href="https://notepad-plus-plus.org/">https://notepad-plus-plus.org/</a></li><li>Sublime Text：<a href="http://www.sublimetext.com/">http://www.sublimetext.com/</a></li><li>VS Code：<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></li><li>WebStorm ：<a href="http://www.jetbrains.com/webstorm/">http://www.jetbrains.com/webstorm/</a></li><li>Sublime Text :<a href="http://www.sublimetext.com/">http://www.sublimetext.com/</a></li></ul><h2 id="css库"><a href="#css库" class="headerlink" title="css库"></a>css库</h2><ol><li><strong>Stylus</strong> - 富有表现力的、动态的、健壮的CSS    </li></ol><ul><li><a href="http://stylus-lang.com/">http://stylus-lang.com/</a></li><li><a href="https://www.zhangxinxu.com/jq/stylus/">https://www.zhangxinxu.com/jq/stylus/</a></li></ul><ol start="2"><li><p><strong>SASS（Syntactically Awesome Stylesheet）</strong>是一个CSS预处理器，有助于减少CSS的重复，节省时间。它是更稳定和强大的CSS扩展语言，描述文档的样式干净和结构。安装<strong>Ruby</strong>打开链接: <a href="https://www.axihe.com/edu/sass/edu/www.ruby-lang.org/en/downloads">www.ruby-lang.org/en/downloads</a>下载zip文件的_当前稳定。</p></li><li><p><strong>LESS</strong>是一个CSS预处理器，可以为网站启用可自定义，可管理和可重用的样式表。要下载<strong>NodeJs</strong>，请打开链接 <a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p></li><li><p><strong>Bootstrap 4</strong>从官网 <a href="https://getbootstrap.com/docs/4.3/getting-started/download/">getbootstrap.com</a> 下载 。</p><p>还可以使用以下的 CDN 服务：</p><p>国内推荐使用 : <a href="https://www.staticfile.org/">https://www.staticfile.org/</a></p><p>国际推荐使用：<a href="https://cdnjs.com/">https://cdnjs.com/</a></p></li><li><p><strong>EasyUI</strong> 是一个基于 jQuery 的框架，集成了各种用户界面插件。 <a href="http://www.easyui.com/download/index.php">http://www.easyui.com/download/index.php</a></p></li><li><p><strong>Foundation</strong> 是一个免费的前端框架，用于快速开发</p><p>从官网下载最新版本：<a href="http://foundation.zurb.com/%E3%80%82">http://foundation.zurb.com/。</a></p><p>使用CDN（推荐）：<a href="https://www.bootcdn.cn/foundation/">https://www.bootcdn.cn/foundation/</a></p></li><li><p>Font Awesome 是一套绝佳的图标字体库和CSS框架</p><p><a href="https://www.bootcdn.cn/font-awesome/">https://www.bootcdn.cn/font-awesome/</a></p></li><li><p><strong>Iconfont</strong>  阿里巴巴矢量图标管理、交流平台，设计师将图标上传到Iconfont平台，用户可以自定义下载多种格式的icon，平台也可将图标转换为字体，便于前端工程师自由调整与调用。<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p></li><li><p><strong>SVG</strong> 意为可缩放矢量图形（Scalable Vector Graphics）</p></li></ol><h2 id="前端必备常用网站"><a href="#前端必备常用网站" class="headerlink" title="前端必备常用网站"></a>前端必备常用网站</h2><h3 id="MDN"><a href="#MDN" class="headerlink" title="MDN"></a>MDN</h3><p>MDN 他原来是 Mozilla 开发者中心, 也就是出火狐浏览器的那个组织的，但是呢,现在他是由一群社区的开发者，还有一些文档专家来维护的这么一个文档项目，它上面有好多关于 web 开发的一些文档，有 html, JavaScript 和 css，还有浏览器内置的一些 web API，包括还有后端的 node.js 和 express 开发。他的文档都很权威，而且很全面，还很新。是咱们这个前端工程师必须要关注的网站。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web">MDN Web Docs</a></p><h3 id="Caniuse"><a href="#Caniuse" class="headerlink" title="Caniuse"></a>Caniuse</h3><p>Caniuse 这个网站它是用来查询一些 css 特性或者是 JavaScript 的特性，能不能在咱们当前的这个浏览器版本里面用，它会有一个详细的列表来显示这个特性哪些浏览器支持，哪些浏览器不支持。如果咱们大家不确定一个属性能不能在一个浏览器上用，可以通过这个网站去查一下。</p><p><a href="https://caniuse.com/">Can I use… Support tables for HTML5, CSS3, etc</a></p><h3 id="Css-tricks"><a href="#Css-tricks" class="headerlink" title="Css-tricks"></a>Css-tricks</h3><p>这个网站是主要介绍 css，另外呢也会有 html，JavaScript 和 php 的文章。他的文章大部分都是关于怎么实现一个 css 的特效，然后有一些 css 的最佳实践，比如说响应式布局，Flexbox 属性详解，或者是实现某一个特定的组件。它的内容有文章形式的，也有视频形式的，还有一些代码的示例，咱们想实现一个特效的时候，可以在这上面找一找。</p><p><a href="https://css-tricks.com/">CSS-Tricks</a></p><h3 id="Codepen"><a href="#Codepen" class="headerlink" title="Codepen"></a>Codepen</h3><p>它是一个在线的代码编辑器，它还支持社交的功能。这样他有好多前端工程师，就把用这个在线编辑器写好了代码共享出来，他这个代码涉及的类别就比较多了，有关于网页组件的，还有关于游戏的，还有关于 3d，和 canvas 的这种。他的首页有列出来的一些比较热门的，大家可以没事浏览浏览，找找灵感。上面的牛人也比较多，它们写的代码都比较高深。</p><p><a href="https://codepen.io/">CodePen: Build, Test, and Discover Front-end Code.</a></p><h3 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h3><p>Medium 是一个现在很火的，特别大的博客平台，它上面的文章什么类别都有。然后关于编程的也有不少，当然也有咱们关于前端的。如果大家用谷歌搜索过的话，那么大部分的搜索结果可能都是这个 medium 平台上的，这上面的文章质量也都比较好。适合咱们大家做一些深入的概念性的学习。</p><p><a href="https://medium.com/">Medium – Get smarter about what matters to you.</a></p><h3 id="Hacker-noon"><a href="#Hacker-noon" class="headerlink" title="Hacker noon"></a>Hacker noon</h3><p>hacker noon 也是一个关于软件开发的平台, 上边也是各种关于软件开发的主题，比如说有加密啊，代码，还有一些创业的，或者是社区、AI 等这些类别。里面关于前端的也不少，而他的文章呢也基本上算是入门到中级的这种比较多。作者的一般文风都很通俗，咱们这一看就能看懂，所以说适合学习一些新的框架的入门还有进阶一点教程</p><p><a href="https://hackernoon.com/">Hacker Noon</a></p><h3 id="StackOverflow"><a href="#StackOverflow" class="headerlink" title="StackOverflow"></a>StackOverflow</h3><p>Stackoverflow，这个算是一个比较老的网站，也算是全世界程序员都知道的一个网站，他是程序员用来问问题还有回答的地方，上面的问题也都是比较精辟，然后回答的也都比较详细，因为它这个社区有一个特别严谨又特别完善的规范，不是什么人都能问出一个好的问题来，如果问得不好的话就会被关闭，回答的不好的话也会被人呛，所以说他这种严谨的规范就造出来了这么一个比较完美的社区，这上面基本上所有的软件开发的问题都能在上面找到，大家搜问题的时候在谷歌上那肯定出来的结果前几条就有这个网站，大家没事也可以去浏览一下，看看有哪些待解决的问题，自己也可以去试着回答一下。只有在自己给别人讲明白了之后，才能说明自己真正的懂了。</p><p><a href="https://stackoverflow.com/">Stack Overflow - Where Developers Learn, Share, &amp; Build Careers</a></p><h3 id="freecodecamp"><a href="#freecodecamp" class="headerlink" title="freecodecamp"></a>freecodecamp</h3><p>FreeCodeCamp 这个网站就比较好玩，它主要是学前端的。然后呢，它是有一系列的学习步骤，然后每个学习章节都有一些小的练习题，然后等把这一套练习都做完之后，就能把这个技术给掌握了。另外呢，他最后还会有练手的项目让大家去做，把这个学完之后，他还可以给你颁发一些证书。</p><p><a href="https://www.freecodecamp.org/">Learn to code|freecodecamp.org</a></p><h3 id="SegmentFault"><a href="#SegmentFault" class="headerlink" title="SegmentFault"></a>SegmentFault</h3><p>思否这个网站算是质量也比较高的，之前有好多同事也推荐给我看，但是呢，他就是只记得这个 logo 是绿色的，他也忘了这个名字是什么，大概这个网站知道他名字比较少，是因为这个名字又长又不好记，它叫 segment fault。里面也是各种文章都有，但是对于前端也是比较多的。</p><p><a href="https://segmentfault.com/">SegmentFault - 思否</a></p><h3 id="掘金"><a href="#掘金" class="headerlink" title="掘金"></a>掘金</h3><p>掘金跟那个 segment fault 这个网站基本上类似，这也是有各种类别的，然后前端的话也算是比较热门的一个类别，但是呢，他这个重点咱们看一下他们这个官网，前端的这些热榜基本上就是关于面试的，还有工作原理的，另外还有一些实践的项目。</p><p><a href="https://juejin.im/timeline">掘金</a></p><h3 id="简书"><a href="#简书" class="headerlink" title="简书"></a>简书</h3><p>简书这个现在已经慢慢的淡出程序员的这个视野，因为他最近改版改的对这个作者都很不友好，但是呢，好歹他也火过一阵，所以这里再推荐一下，上面还会有一些遗留的比较好的文章。大家如果搜索某个问题或者是某个概念的时候，关注一下这个简书的搜索结果也可以。</p><p><a href="https://www.jianshu.com/">简书 - 创作你的创作</a></p><h3 id="CSDN"><a href="#CSDN" class="headerlink" title="CSDN"></a>CSDN</h3><p>CSDN 算是一个特别老牌的社区了，我也是从 2010 年在上边写了第 1 篇文章，然后到现在就已经有 10 年多了，也断断续续的没写过多少，当时 10 年的时候写文章还是有好多阅读量，但是现在的话写完基本上就没什么看， 上面的人就已经是特别爆满了，而且。这文章也是质量参差不齐，它的推荐系统也一直在改版，所以现在还不好说未来是什么样子。如果大家用百度搜问题的话，可能它的这个搜索结果会比较多，但是就是对作者不太友好，因为他有好多文章就是容易被抄袭，好多就是写的一模一样的。但是呢，它上面有一些新闻，还有一些有价值的文章，大家还是可以去关注一下。</p><p><a href="https://www.csdn.net/">CSDN - 专业的技术社区</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 常用链接 </category>
          
          <category> 资源网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 资源网站 </tag>
            
            <tag> 提升必备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯云部署hexo</title>
      <link href="posts/a34f529.html"/>
      <url>posts/a34f529.html</url>
      
        <content type="html"><![CDATA[<h1 id="腾讯云部署hexo"><a href="#腾讯云部署hexo" class="headerlink" title="腾讯云部署hexo"></a>腾讯云部署hexo</h1><h3 id="一、部署环境与准备"><a href="#一、部署环境与准备" class="headerlink" title="一、部署环境与准备"></a>一、部署环境与准备</h3><h5 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h5><p>本地Windows10操作系统</p><p>腾讯云Cenots7.6服务器</p><h5 id="2-准备"><a href="#2-准备" class="headerlink" title="2.准备"></a>2.准备</h5><p>Hexo 本地博客</p><p>腾讯云终端操作</p><h3 id="二、云服务器配置Git"><a href="#二、云服务器配置Git" class="headerlink" title="二、云服务器配置Git"></a>二、云服务器配置Git</h3><h4 id="1-安装依赖库"><a href="#1-安装依赖库" class="headerlink" title="1.安装依赖库"></a>1.安装依赖库</h4><pre class="line-numbers language-none"><code class="language-none">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-安装编译工具"><a href="#2-安装编译工具" class="headerlink" title="2.安装编译工具"></a>2.安装编译工具</h4><pre class="line-numbers language-none"><code class="language-none">yum install gcc perl-ExtUtils-MakeMaker package<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-查看git的版本y"><a href="#3-查看git的版本y" class="headerlink" title="3.查看git的版本y"></a>3.查看git的版本y</h4><pre class="line-numbers language-none"><code class="language-none">git version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-删除git"><a href="#4-删除git" class="headerlink" title="4.删除git"></a>4.删除git</h4><pre class="line-numbers language-none"><code class="language-none">yum remove git -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-下载解压最新版"><a href="#5-下载解压最新版" class="headerlink" title="5.下载解压最新版"></a>5.下载解压最新版</h4><pre class="line-numbers language-none"><code class="language-none">cd /usr/local/src     #下载的目录wget http://ftp.ntu.edu.tw/software/scm/git/git-2.9.5.tar.gz       #下载最新版 tar -zvxf git-2.9.5.tar.gz          #解压到当前文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="6-编辑并安装"><a href="#6-编辑并安装" class="headerlink" title="6.编辑并安装"></a>6.编辑并安装</h4><pre class="line-numbers language-none"><code class="language-none">cd git-2.9.5 #进入文件夹make prefix=/usr/local/git all    #编译源码make prefix=/usr/local/git install    #安装路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="7-配置git的环境变量"><a href="#7-配置git的环境变量" class="headerlink" title="7.配置git的环境变量"></a>7.配置git的环境变量</h4><pre class="line-numbers language-none"><code class="language-none">echo 'export PATH=$PATH:/usr/local/git/bin' &gt;&gt; /etc/bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="8-刷新环境变量"><a href="#8-刷新环境变量" class="headerlink" title="8.刷新环境变量"></a>8.刷新环境变量</h4><pre class="line-numbers language-none"><code class="language-none">source /etc/bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="9-查看版本号"><a href="#9-查看版本号" class="headerlink" title="9.查看版本号"></a>9.查看版本号</h4><pre class="line-numbers language-none"><code class="language-none">git --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="10创建git用户并且修改权限"><a href="#10创建git用户并且修改权限" class="headerlink" title="10创建git用户并且修改权限"></a>10创建git用户并且修改权限</h4><pre class="line-numbers language-none"><code class="language-none">adduser CodeChengpasswd CodeChengchmod 740 /etc/sudoersvim /etc/sudoersroot    ALL=(ALL)       ALLCodeCheng     ALL=(ALL)       ALL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="11-本地windows10使用Gitbash创建密钥"><a href="#11-本地windows10使用Gitbash创建密钥" class="headerlink" title="11.本地windows10使用Gitbash创建密钥"></a>11.本地windows10使用Gitbash创建密钥</h4><pre class="line-numbers language-none"><code class="language-none">ssh-keygen -t rsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="12-将本地创建id-rsa-pub中文件复制"><a href="#12-将本地创建id-rsa-pub中文件复制" class="headerlink" title="12.将本地创建id_rsa.pub中文件复制"></a>12.将本地创建id_rsa.pub中文件复制</h4><pre class="line-numbers language-none"><code class="language-none">su CodeChengmkdir ~/.sshvim ~/.ssh/authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="13-本地测试"><a href="#13-本地测试" class="headerlink" title="13.本地测试"></a>13.本地测试</h4><pre class="line-numbers language-none"><code class="language-none">ssh -v CodeCheng@服务器ipssh -v CodeCheng1.15.122.167<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
          <category> 部署远端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 腾讯云 </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法</title>
      <link href="posts/f134a8e5.html"/>
      <url>posts/f134a8e5.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、为什么要学习-Markdown？"><a href="#一、为什么要学习-Markdown？" class="headerlink" title="一、为什么要学习 Markdown？"></a>一、为什么要学习 Markdown？</h1><ul><li><strong>语法简练，上手迅速</strong></li><li><strong>纯文本、轻量级</strong></li><li><strong>支持协作开发</strong></li><li><strong>所想即所得</strong></li><li><strong>跨平台、高兼容</strong></li><li><strong>使用广泛</strong></li></ul><h1 id="二、Markdown-语法"><a href="#二、Markdown-语法" class="headerlink" title="二、Markdown 语法"></a>二、Markdown 语法</h1><ul><li>工具下载推荐：Typora </li><li>下载地址：<a href="https://www.typora.io/">https://www.typora.io/</a></li></ul><h2 id="2-1-标题"><a href="#2-1-标题" class="headerlink" title="2.1 标题"></a>2.1 标题</h2><p>使用多个 <code>#</code> 的方式实现标题，Markdown 支持 1 ~ 6 级标题，6级标题以上将不会被识别。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-粗体、斜体、删除、分割线、更改颜色"><a href="#2-2-粗体、斜体、删除、分割线、更改颜色" class="headerlink" title="2.2 粗体、斜体、删除、分割线、更改颜色"></a>2.2 粗体、斜体、删除、分割线、更改颜色</h2><p>使用单个<code> *</code> 号包裹文字，实现斜体的效果：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">*这是斜体效果*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用两个<code>*</code>号包裹文字，实现粗体的效果：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">**这是粗体效果**<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用两个<code>~</code>号包裹文字，实现删除的效果：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">~~这是删除效果~~~<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用连续三个短横线 <code>- </code>实现添加分割线：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">---<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Markdown 不支持文字更改颜色，如需支持，请使用 HTML 标签，例如红色：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">&lt;font color="red"&gt;红色&lt;/font&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-3-有序列表、无序列表"><a href="#2-3-有序列表、无序列表" class="headerlink" title="2.3 有序列表、无序列表"></a>2.3 有序列表、无序列表</h2><p>使用数字加+ <code>.</code> 加空格实现有序列表：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">1. 第一点2. 第二点3. 第三点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用短横线<code>-</code>加空格实现无序列表：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">- 周一- 周二- 周三<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果想实现多级列表，子列表应保持与父列表<strong>2个或4个空格缩进：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">- 贵州  - 贵阳  - 遵义- 四川  - 隆昌  - 成都<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4-表格"><a href="#2-4-表格" class="headerlink" title="2.4 表格"></a>2.4 表格</h2><ol><li>表格第一行为表头，通过<code>|</code>分割每一列，在 <code>| </code>中间填写表头信息。</li><li>表格第二行为表格信息，使用<code> |</code> 分割列，每两个<code>|</code>中间使用<code> -</code>填充。</li></ol><ul><li>默认表格居中对齐<ol><li>在 <code>- </code>左侧添加<code>: </code>将该列左对齐</li><li>在 <code>-</code> 右侧添加<code>: </code>将该列右对齐</li><li>从第三行开始为表格体信息。</li></ol></li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">|列1|列2|列3||:-|-|-:||a|b|c|<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>Tips：表格每个单元格内不支持换行，如果需要换行，请使用 <br> 标签。</p></blockquote><h2 id="2-5-超链接、图片、视频"><a href="#2-5-超链接、图片、视频" class="headerlink" title="2.5 超链接、图片、视频"></a>2.5 超链接、图片、视频</h2><p>使用如下方式实现超链接：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">[文字描述](链接网址)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>Tips: Markdown 超链接不支持新窗口打开，如需要，请使用 <a target="_blank"> 实现。</a></p><a target="_blank"></a></blockquote><a target="_blank"><p>使用如下方式实现插入图片：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">![图片描述](图片网址)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>Tips: Markdown 图片不支持居中对齐、调整大小，如需要，请使用：</p><img src="C:/Users/Daly/Desktop/md%25E7%25AC%2594%25E8%25AE%25B0%25E6%2595%25B4%25E7%2590%2586%25E5%25B8%25B8%25E7%2594%25A8%25E5%259B%25BE%25E7%2589%2587%25E6%2595%25B4%25E7%2590%2586/%25E6%259D%2582%25E4%25B8%2583%25E6%259D%2582%25E5%2585%25AB/%25E5%259B%25BE%25E7%2589%2587%25E7%25BD%2591%25E5%259D%2580" alt="图片描述" width="80%" height="80%"><p>建议 width 和 height 建议只设置一个，避免图片拉伸。</p></blockquote><p>Markdown 本身是不支持视频的，但是我们可以通过 HTML 的 Iframe 来实现，在大部分的视频网站中，通过点击视频下方的获取嵌入代码，并将其粘入 Markdown 中即可。</p><p><img src="https://cdn.jsdelivr.net/gh/jitwxs/cdn/blog/posts/201903/20190316191716824.png"></p><blockquote><p>Tips：视频自适应大小在 Markdown 中的实现比较复杂，受限于 Iframe 的特性，一般需要通过调整渲染的样式或其他途径来实现。例如在 Hexo 中调整主题的样式实现，或在 Gitbook 中按转换视频插件。</p></blockquote></a><h2 id="2-6-块与引用"><a target="_blank"></a><a href="#2-6-块与引用" class="headerlink" title="2.6 块与引用"></a>2.6 块与引用</h2><p>使用 <code>&gt; </code>实现块级引用，一般用于引用其他出处内容。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">&gt;鲁迅曾今说过：...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>块引用也支持多级嵌套，例如二级嵌套：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">&gt;这是一级块引用&gt;&gt;这是二级块引用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>Tips: 块引用中多段文字不支持空行，如需添加空行，请使用<br></p></blockquote><p>使用反单引号包裹文字，实现行内引用，一般用于名词，例如：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">`Nginx` 是一个反向代理的服务器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Markdown 支持插入代码块，使用三个反单引号加要高亮的语言名包裹代码块实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) {    sout("Hello World!");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2-7-数学公式"><a href="#2-7-数学公式" class="headerlink" title="2.7 数学公式"></a>2.7 数学公式</h2><p>绝大部分 Markdown 解释引擎支持 Mathjax 数学公式,这里只列出常见的符号。</p><p>使用 \frac{}{}表示除法，使用 \ast 表示乘号，例如：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">f(x) = \frac{a+b}{a \ast b}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 ^ 和 _ 分别表示上标和下标，使用 \sum_{}^{}表示求和符号，例如：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">\sum_{n=1}^{n&lt;10} n^2 + 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-8-目录"><a href="#2-8-目录" class="headerlink" title="2.8 目录"></a>2.8 目录</h2><p>Markdown 原生不支持目录，但是绝大部分的 Markdown 引擎都支持，一般使用 [toc] 实现，少部分使用 @[toc] 实现。</p><h2 id="2-9-首行缩进"><a href="#2-9-首行缩进" class="headerlink" title="2.9 首行缩进"></a>2.9 首行缩进</h2><p>Markdown 本身不支持首行缩进，因此在中文模式下可以使用   实现空出一个中文字符，例如：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">&amp;emsp;&amp;emsp;首行缩进两个字符<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-更多用法"><a href="#3-更多用法" class="headerlink" title="3.更多用法"></a>3.更多用法</h2><p>Markdown 还支持更多功能，例如制作流程图、甘特图等，但上手难度大，与传统方式相比优势不大，因此看个人喜好而定。</p><h2 id="3-1、流程图"><a href="#3-1、流程图" class="headerlink" title="3.1、流程图"></a>3.1、流程图</h2><p><strong>代码如下：</strong></p><p>```flow<br>st=&gt;start: 开始框<br>op=&gt;operation: 处理框<br>cond=&gt;condition: 判断框(是或否?)<br>sub1=&gt;subroutine: 子流程<br>io=&gt;inputoutput: 输入输出框<br>e=&gt;end: 结束框<br>st-&gt;op-&gt;cond<br>cond(yes)-&gt;io-&gt;e<br>cond(no)-&gt;sub1(right)-&gt;op<br>```</p><p><strong>效果如下：</strong></p><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/02/02/kuangstudy91c6ede3-259c-4477-98f5-9325db22c7b1.png" alt="img"></p><h2 id="3-2UML时序图"><a href="#3-2UML时序图" class="headerlink" title="3.2UML时序图"></a>3.2UML时序图</h2><p><strong>代码如下：</strong></p><p>```sequence<br>对象A-&gt;对象B: 对象B你好吗?（请求）<br>Note right of 对象B: 对象B的描述<br>Note left of 对象A: 对象A的描述(提示)<br>对象B—&gt;对象A: 我很好(响应)<br>对象A-&gt;对象B: 你真的好吗？<br>```</p><p><strong>效果如下：</strong></p><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/02/02/kuangstudy56ace13c-ded4-4a2f-a2ed-b66fdaff49fd.png" alt="img"></p><h2 id="3-3Typora设置Vue主题"><a href="#3-3Typora设置Vue主题" class="headerlink" title="3.3Typora设置Vue主题"></a>3.3Typora设置Vue主题</h2><p>一、下载Vue主题<br>地址：<a href="http://theme.typora.io/theme/Vue/">http://theme.typora.io/theme/Vue/</a></p><p><img src="https://img-blog.csdnimg.cn/20200814220028581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2luX3RoZV9yb2Fk,size_16,color_FFFFFF,t_70"></p><p>二、添加主题<br>1、打开Typora，点击左上角 “文件” -&gt;“偏好设置” -&gt; “打开主题文件夹”</p><p><img src="https://img-blog.csdnimg.cn/20200814220352764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2luX3RoZV9yb2Fk,size_16,color_FFFFFF,t_70"></p><p>2、解压下载后的Vue主题zip包，并把里面的vue文件夹、vue.css、vue-dark.css拷贝至刚刚打开的主题文件夹</p><p><img src="https://img-blog.csdnimg.cn/20200814220626399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2luX3RoZV9yb2Fk,size_16,color_FFFFFF,t_70"></p><p>3、拷贝后的结果</p><p><img src="https://img-blog.csdnimg.cn/20200814220823332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2luX3RoZV9yb2Fk,size_16,color_FFFFFF,t_70"></p><p>三、设置主题</p><p><strong>1、重启 Typora</strong></p><p><strong>2、点击菜单栏的“主题”，然后勾选“Vue”，下图就是设置后的效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200814221455334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2luX3RoZV9yb2Fk,size_16,color_FFFFFF,t_70"></p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
          <category> 写博客 </category>
          
          <category> Typroa </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 语法 </tag>
            
            <tag> Typroa </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
